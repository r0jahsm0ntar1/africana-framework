package securities

import(
    "os"
    "fmt"
    "time"
    "bufio"
    "utils"
    "menus"
    "regexp"
    "banners"
    "strings"
    "bcolors"
    "os/exec"
    "net/http"
    "io/ioutil"
    "subprocess"
    "scriptures"
)

var (
    Input, Proxy, Module string
    scanner  = bufio.NewScanner(os.Stdin)
)

var torrString = []string{
    "# Generated by africana-framework. Delete at your own risk!\n",
    "VirtualAddrNetwork 10.192.0.0/10",
    "AutomapHostsOnResolve 1",
    "CookieAuthentication 1",
    "TransPort 9040",
    "SocksPort 9050",
    "DNSPort 5353",
}

func Anonsurf() {
    for {
        fmt.Printf("%s%safr3%s anonsurf(%s%s%s)%s > %s", bcolors.UNDERL, bcolors.BOLD, bcolors.ENDC, bcolors.RED, "securities_setup.fn", bcolors.ENDC, bcolors.GREEN, bcolors.ENDC)
        scanner.Scan()
        Input = strings.TrimSpace(strings.ToLower(scanner.Text()))
        buildParts := strings.Fields(Input)
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeModule()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandMap := map[string]func(){

        "? info":           menus.HelpInfo,
        "help info":        menus.HelpInfo,

        "v":                banners.Version,
        "version":          banners.Version,

        "s":                utils.Sleep,
        "sleep":            utils.Sleep,

        "o":                utils.ListJunks,
        "junks":            utils.ListJunks,
        "outputs":          utils.ListJunks,
        "clear junks":      utils.ClearJunks,
        "clear outputs":    utils.ClearJunks,

        "logs":             subprocess.LogHistory,
        "history":          subprocess.LogHistory,
        "clear logs":       subprocess.ClearHistory,
        "clear history":    subprocess.ClearHistory,

        "? run":            menus.HelpInfoRun,
        "h run":            menus.HelpInfoRun,
        "info run":         menus.HelpInfoRun,
        "help run":         menus.HelpInfoRun,
        "? use":            menus.HelpInfoRun,
        "h use":            menus.HelpInfoRun,
        "info use":         menus.HelpInfoRun,
        "help use":         menus.HelpInfoRun,
        "? exec":           menus.HelpInfoRun,
        "h exec":           menus.HelpInfoRun,
        "info exec":        menus.HelpInfoRun,
        "help exec":        menus.HelpInfoRun,
        "? start":          menus.HelpInfoRun,
        "h start":          menus.HelpInfoRun,
        "info start":       menus.HelpInfoRun,
        "help start":       menus.HelpInfoRun,
        "? launch":         menus.HelpInfoRun,
        "h launch":         menus.HelpInfoRun,
        "info launch":      menus.HelpInfoRun,
        "help launch":      menus.HelpInfoRun,
        "? exploit":        menus.HelpInfoRun,
        "h exploit":        menus.HelpInfoRun,
        "info exploit":     menus.HelpInfoRun,
        "help exploit":     menus.HelpInfoRun,
        "? execute":        menus.HelpInfoRun,
        "h execute":        menus.HelpInfoRun,
        "info execute":     menus.HelpInfoRun,
        "help execute":     menus.HelpInfoRun,

        "set":              menus.HelpInfoSet,
        "h set":            menus.HelpInfoSet,
        "info set":         menus.HelpInfoSet,
        "help set":         menus.HelpInfoSet,

        "tips":             menus.HelpInfoTips,
        "h tips":           menus.HelpInfoTips,
        "? tips":           menus.HelpInfoTips,
        "info tips":        menus.HelpInfoTips,
        "help tips":        menus.HelpInfoTips,

        "show":             menus.HelpInfoShow,
        "? show":           menus.HelpInfoShow,
        "h show":           menus.HelpInfoShow,
        "info show":        menus.HelpInfoShow,
        "help show":        menus.HelpInfoShow,

        "info list":        menus.HelpInfoList,
        "help list":        menus.HelpInfoList,
        "use list":         menus.HelpInfoList,
        "list":             menus.HelpInfoList,

        "? options":        menus.HelpInfOptions,
        "info options":     menus.HelpInfOptions,
        "help options":     menus.HelpInfOptions,

        "banner":           banners.RandomBanners,
        "g":                utils.BrowseTutarilas,
        "t":                utils.BrowseTutarilas,
        "guide":            utils.BrowseTutarilas,
        "tutarial":         utils.BrowseTutarilas,
        "h":                menus.HelpInfoMenuZero,
        "?":                menus.HelpInfoMenuZero,
        "00":               menus.HelpInfoMenuZero,
        "help":             menus.HelpInfoMenuZero,
        "f":                menus.HelpInfoFeatures,
        "use f":            menus.HelpInfoFeatures,
        "features":         menus.HelpInfoFeatures,
        "use features":     menus.HelpInfoFeatures,

        //Chameleons//
        "info":             menus.HelpInfoAnonsurf,

        "m":                menus.MenuTwo,
        "menu":             menus.MenuTwo,

        "option":           menus.AnonsurfOptions,
        "options":          menus.AnonsurfOptions,
        "show option":      menus.AnonsurfOptions,
        "show options":     menus.AnonsurfOptions,

        "modules":          menus.ListAnonsurfModules,
        "show all":         menus.ListAnonsurfModules,
        "list all":         menus.ListAnonsurfModules,
        "list modules":     menus.ListAnonsurfModules,
        "show modules":     menus.ListAnonsurfModules,

        "1":                func() {AnonimityModules("setups")},
        "run 1":            func() {AnonimityModules("setups")},
        "use 1":            func() {AnonimityModules("setups")},
        "exec 1":           func() {AnonimityModules("setups")},
        "start 1":          func() {AnonimityModules("setups")},
        "launch 1":         func() {AnonimityModules("setups")},
        "exploit 1":        func() {AnonimityModules("setups")},
        "execute 1":        func() {AnonimityModules("setups")},
        "run setups":       func() {AnonimityModules("setups")},
        "use setups":       func() {AnonimityModules("setups")},
        "exec setups":      func() {AnonimityModules("setups")},
        "start setups":     func() {AnonimityModules("setups")},
        "launch setups":    func() {AnonimityModules("setups")},
        "exploit setups":   func() {AnonimityModules("setups")},
        "execute setups":   func() {AnonimityModules("setups")},

        "? 1":              menus.HelpInfoAnonsurfSetups,
        "info 1":           menus.HelpInfoAnonsurfSetups,
        "help 1":           menus.HelpInfoAnonsurfSetups,
        "setups":           menus.HelpInfoAnonsurfSetups,
        "info setups":      menus.HelpInfoAnonsurfSetups,
        "help setups":      menus.HelpInfoAnonsurfSetups,

        "2":                func() {AnonimityModules("start")},
        "run 2":            func() {AnonimityModules("start")},
        "use 2":            func() {AnonimityModules("start")},
        "exec 2":           func() {AnonimityModules("start")},
        "start 2":          func() {AnonimityModules("start")},
        "launch 2":         func() {AnonimityModules("start")},
        "exploit 2":        func() {AnonimityModules("start")},
        "execute 2":        func() {AnonimityModules("start")},
        "run anonsurf":     func() {AnonimityModules("start")},
        "use anonsurf":     func() {AnonimityModules("start")},
        "exec anonsurf":    func() {AnonimityModules("start")},
        "start anonsurf":   func() {AnonimityModules("start")}, 
        "launch anonsurf":  func() {AnonimityModules("start")},
        "exploit anonsurf": func() {AnonimityModules("start")},
        "execute anonsurf": func() {AnonimityModules("start")},

        "? 2":              menus.HelpInfoAnonsurfStart,
        "info 2":           menus.HelpInfoAnonsurfStart,
        "help 2":           menus.HelpInfoAnonsurfStart,
        "anonsurf":         menus.HelpInfoAnonsurfStart,
        "info anonsurf":    menus.HelpInfoAnonsurfStart,
        "help anonsurf":    menus.HelpInfoAnonsurfStart,

        "3":                func() {AnonimityModules("exitnode")},
        "run 3":            func() {AnonimityModules("exitnode")},
        "use 3":            func() {AnonimityModules("exitnode")},
        "exec 3":           func() {AnonimityModules("exitnode")},
        "start 3":          func() {AnonimityModules("exitnode")},
        "launch 3":         func() {AnonimityModules("exitnode")},
        "exploit 3":        func() {AnonimityModules("exitnode")},
        "execute 3":        func() {AnonimityModules("exitnode")},
        "run networks":     func() {AnonimityModules("exitnode")},
        "use networks":     func() {AnonimityModules("exitnode")},
        "exec networks":    func() {AnonimityModules("exitnode")},
        "start networks":   func() {AnonimityModules("exitnode")},
        "launch networks":  func() {AnonimityModules("exitnode")},
        "exploit networks": func() {AnonimityModules("exitnode")},
        "execute networks": func() {AnonimityModules("exitnode")},

        "? 3":              menus. HelpInfoAnonsurfExitnode,
        "info 3":           menus. HelpInfoAnonsurfExitnode,
        "help 3":           menus. HelpInfoAnonsurfExitnode,
        "networks":         menus. HelpInfoAnonsurfExitnode,
        "info networks":    menus. HelpInfoAnonsurfExitnode,
        "help networks":    menus. HelpInfoAnonsurfExitnode,

        "4":                func() {AnonimityModules("status")},
        "run 4":            func() {AnonimityModules("status")},
        "use 4":            func() {AnonimityModules("status")},
        "exec 4":           func() {AnonimityModules("status")},
        "start 4":          func() {AnonimityModules("status")},
        "launch 4":         func() {AnonimityModules("status")},
        "exploit 4":        func() {AnonimityModules("status")},
        "execute 4":        func() {AnonimityModules("status")},
        "run exploits":     func() {AnonimityModules("status")},
        "use exploits":     func() {AnonimityModules("status")},
        "exec exploits":    func() {AnonimityModules("status")},
        "start exploits":   func() {AnonimityModules("status")},
        "launch exploits":  func() {AnonimityModules("status")},
        "exploit exploits": func() {AnonimityModules("status")},
        "execute exploits": func() {AnonimityModules("status")},

        "? 4":              menus.HelpInfoAnonsurfStatus,
        "info 4":           menus.HelpInfoAnonsurfStatus,
        "help 4":           menus.HelpInfoAnonsurfStatus,
        "exploits":         menus.HelpInfoAnonsurfStatus,
        "info exploits":    menus.HelpInfoAnonsurfStatus,
        "help exploits":    menus.HelpInfoAnonsurfStatus,

        "5":                func() {AnonimityModules("ipaddress")},
        "run 5":            func() {AnonimityModules("ipaddress")},
        "use 5":            func() {AnonimityModules("ipaddress")},
        "exec 5":           func() {AnonimityModules("ipaddress")},
        "start 5":          func() {AnonimityModules("ipaddress")},
        "launch 5":         func() {AnonimityModules("ipaddress")},
        "exploit 5":        func() {AnonimityModules("ipaddress")},
        "execute 5":        func() {AnonimityModules("ipaddress")},
        "run wireless":     func() {AnonimityModules("ipaddress")},
        "use wireless":     func() {AnonimityModules("ipaddress")},
        "exec wireless":    func() {AnonimityModules("ipaddress")},
        "start wireless":   func() {AnonimityModules("ipaddress")},
        "launch wireless":  func() {AnonimityModules("ipaddress")},
        "exploit wireless": func() {AnonimityModules("ipaddress")},
        "execute wireless": func() {AnonimityModules("ipaddress")},

        "? 5":              menus.HelpInfoAnonsurfIpaddress,
        "info 5":           menus.HelpInfoAnonsurfIpaddress,
        "help 5":           menus.HelpInfoAnonsurfIpaddress,
        "wireless":         menus.HelpInfoAnonsurfIpaddress,
        "info wireless":    menus.HelpInfoAnonsurfIpaddress,
        "help wireless":    menus.HelpInfoAnonsurfIpaddress,

        "6":                func() {AnonimityModules("restore")},
        "run 6":            func() {AnonimityModules("restore")},
        "use 6":            func() {AnonimityModules("restore")},
        "exec 6":           func() {AnonimityModules("restore")},
        "start 6":          func() {AnonimityModules("restore")},
        "launch 6":         func() {AnonimityModules("restore")},
        "exploit 6":        func() {AnonimityModules("restore")},
        "execute 6":        func() {AnonimityModules("restore")},
        "run crackers":     func() {AnonimityModules("restore")},
        "use crackers":     func() {AnonimityModules("restore")},
        "exec crackers":    func() {AnonimityModules("restore")},
        "start crackers":   func() {AnonimityModules("restore")},
        "launch crackers":  func() {AnonimityModules("restore")},
        "exploit crackers": func() {AnonimityModules("restore")},
        "execute crackers": func() {AnonimityModules("restore")},

        "? 6":              menus.HelpInfoAnonsurfRestore,
        "info 6":           menus.HelpInfoAnonsurfRestore,
        "help 6":           menus.HelpInfoAnonsurfRestore,
        "crackers":         menus.HelpInfoAnonsurfRestore,
        "info crackers":    menus.HelpInfoAnonsurfRestore,
        "help crackers":    menus.HelpInfoAnonsurfRestore,

        "7":                func() {AnonimityModules("reload")},
        "run 7":            func() {AnonimityModules("reload")},
        "use 7":            func() {AnonimityModules("reload")},
        "exec 7":           func() {AnonimityModules("reload")},
        "start 7":          func() {AnonimityModules("reload")},
        "launch 7":         func() {AnonimityModules("reload")},
        "exploit 7":        func() {AnonimityModules("reload")},
        "execute 7":        func() {AnonimityModules("reload")},
        "run phishers":     func() {AnonimityModules("reload")},
        "use phishers":     func() {AnonimityModules("reload")},
        "exec phishers":    func() {AnonimityModules("reload")},
        "start phishers":   func() {AnonimityModules("reload")},
        "launch phishers":  func() {AnonimityModules("reload")},
        "exploit phishers": func() {AnonimityModules("reload")},
        "execute phishers": func() {AnonimityModules("reload")},

        "? 7":              menus.HelpInfoAnonsurfReload,
        "info 7":           menus.HelpInfoAnonsurfReload,
        "help 7":           menus.HelpInfoAnonsurfReload,
        "phishers":         menus.HelpInfoAnonsurfReload,
        "info phishers":    menus.HelpInfoAnonsurfReload,
        "help phishers":    menus.HelpInfoAnonsurfReload,

        "8":                func() {AnonimityModules("chains")},
        "run 8":            func() {AnonimityModules("chains")},
        "use 8":            func() {AnonimityModules("chains")},
        "exec 8":           func() {AnonimityModules("chains")},
        "start 8":          func() {AnonimityModules("chains")},
        "launch 8":         func() {AnonimityModules("chains")},
        "exploit 8":        func() {AnonimityModules("chains")},
        "execute 8":        func() {AnonimityModules("chains")},
        "run websites":     func() {AnonimityModules("chains")},
        "use websites":     func() {AnonimityModules("chains")},
        "exec websites":    func() {AnonimityModules("chains")},
        "start websites":   func() {AnonimityModules("chains")},
        "launch websites":  func() {AnonimityModules("chains")},
        "exploit websites": func() {AnonimityModules("chains")},
        "execute websites": func() {AnonimityModules("chains")},

        "? 8":              menus.HelpInfoAnonsurfChains,
        "info 8":           menus.HelpInfoAnonsurfChains,
        "help 8":           menus.HelpInfoAnonsurfChains,
        "websites":         menus.HelpInfoAnonsurfChains,
        "info websites":    menus.HelpInfoAnonsurfChains,
        "help websites":    menus.HelpInfoAnonsurfChains,

        "9":               func() {AnonimityModules("stop")},
        "run 9":           func() {AnonimityModules("stop")},
        "use 9":           func() {AnonimityModules("stop")},
        "exec 9":          func() {AnonimityModules("stop")},
        "start 9":         func() {AnonimityModules("stop")},
        "launch 9":        func() {AnonimityModules("stop")},
        "exploit 9":       func() {AnonimityModules("stop")},
        "execute 9":       func() {AnonimityModules("stop")},
        "run credits":     func() {AnonimityModules("stop")},
        "use credits":     func() {AnonimityModules("stop")},
        "exec credits":    func() {AnonimityModules("stop")},
        "start credits":   func() {AnonimityModules("stop")},
        "launch credits":  func() {AnonimityModules("stop")},
        "exploit credits": func() {AnonimityModules("stop")},
        "execute credits": func() {AnonimityModules("stop")},

        "? 9":              menus.HelpInfoAnonsurfStop,
        "info 9":           menus.HelpInfoAnonsurfStop,
        "help 9":           menus.HelpInfoAnonsurfStop,
        "credits":          menus.HelpInfoAnonsurfStop,
        "info credits":     menus.HelpInfoAnonsurfStop,
        "help credits":     menus.HelpInfoAnonsurfStop,

        "99":               scriptures.ScriptureNarators,
        "run 99":           scriptures.ScriptureNarators,
        "use 99":           scriptures.ScriptureNarators,
        "exec 99":          scriptures.ScriptureNarators,
        "start 99":         scriptures.ScriptureNarators,
        "launch 99":        scriptures.ScriptureNarators,
        "exploit 99":       scriptures.ScriptureNarators,
        "execute 99":       scriptures.ScriptureNarators,
        "run verses":       scriptures.ScriptureNarators,
        "use verses":       scriptures.ScriptureNarators,
        "exec verses":      scriptures.ScriptureNarators,
        "start verses":     scriptures.ScriptureNarators,
        "launch verses":    scriptures.ScriptureNarators,
        "exploit verses":   scriptures.ScriptureNarators,
        "execute verses":   scriptures.ScriptureNarators,

        "? 99":             menus.HelpInfoVerses,
        "verses":           menus.HelpInfoVerses,
        "info 99":          menus.HelpInfoVerses,
        "help 99":          menus.HelpInfoVerses,
        "info verses":      menus.HelpInfoVerses,
        "help verses":      menus.HelpInfoVerses,

    }
    if action, exists := commandMap[cmd]; exists {
        action()
        return true
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{
        "proxy": &Proxy,
        "module": &Module,
    }
    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{
        "proxy": &Proxy,
        "module": &Module,
    }
    if ptr, exists := unsetValues[key]; exists {
        *ptr = ""
        fmt.Printf("%s => None\n", strings.ToUpper(key))
    } else {
        menus.HelpInfoSet()
    }
}

func executeModule() {
    if Module == ""{
        fmt.Printf("\n%s[!] %sMissing required parameter MODULE. Use %s'help' %sfor details.\n", bcolors.RED, bcolors.ENDC, bcolors.DARKGREEN, bcolors.ENDC)
        return
    }
    AnonimityModules(Module)
}

func AnonimityModules(module string, args ...interface{}) {
    fmt.Printf("\nMODULE => %s\n", module)
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        utils.SetProxy(Proxy)
    }

    commands := map[string]func() {
        "setups": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`apt-get update; apt-get install -y tor squid privoxy dnsmasq iptables isc-dhcp-client isc-dhcp-server`); fmt.Println()},
         "start": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configDhclient(); ConfigChangeMac(); configDnsmasq(); configSquid(); configPrivoxy(); configFirewall(); torStatus(0)},
        "status": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`systemctl --no-pager -l status changemac@eth0.service dnsmasq.service squid.service privoxy.service tor@default.service`); fmt.Println()},
      "exitnode": func() {banners.GraphicsTorNet(); fmt.Println(); torCircuit()},
     "ipaddress": func() {banners.GraphicsTorNet(); fmt.Println(); torStatus(0)},
       "restore": func() {banners.GraphicsTorNet(); fmt.Println(); resetToDefault(false, false)},
        "chains": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`tail -vf /var/log/privoxy/logfile`); fmt.Println()},
        "reload": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configFirewall(); torStatus(0)},
          "stop": func() {banners.GraphicsTorNet(); fmt.Println(); termiNate()},
    }

    if action, exists := commands[module]; exists {
        action()
    } else {
        fmt.Printf("\n%s[!] %sInvalid module %s. Use %s'help' %sfor available modules.\n", bcolors.YELLOW, bcolors.ENDC, module, bcolors.DARKGREEN, bcolors.ENDC)
    }
}

func configTorrc() {
    if strings.Contains(flaG(), "anonsurf") {
        fmt.Print(bcolors.DARKCYAN + "\n              Anonsurf: " + bcolors.ENDC + "is already running ...\n" + bcolors.ENDC)
        //os.Exit(1)
    }

    rSwitch := cypheR(0, 0)

    if _, err := exec.LookPath("tor"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install tor'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }

    if _, err := os.Stat("/etc/tor/torrc"); os.IsNotExist(err) {
        fmt.Printf("%sNo torrc file is configured ...%s%sConfiguring:)%s\n", bcolors.RED, bcolors.ENDC, bcolors.GREEN, bcolors.ENDC)
        file, err := os.Create("/etc/tor/torrc")
        if err != nil {
            fmt.Printf("%sFailed to write the torrc file%s \n %s", bcolors.RED, bcolors.ENDC, err)
            //os.Exit(1)
        }
        defer file.Close()
        for _, element := range torrString {
            file.WriteString(element + "\n")
        }
        fmt.Printf("%sDone ...%s\n", bcolors.CYAN, bcolors.ENDC)
    } else {
        fmt.Println(bcolors.BLUE + "\n(" + bcolors.ORANGE + "Configuring Torrc ..." + bcolors.ENDC)
        time.Sleep(400 * time.Millisecond)
        cmd := exec.Command("cp", "/etc/tor/torrc", "/etc/tor/torrc.bak_anonsurf")
        cmd.Run()
        file, err := os.Create("/etc/tor/torrc")
        if err != nil {
            fmt.Printf("%s\n", err)
            //os.Exit(1)
        }
        defer file.Close()
        for _, element := range torrString {
            file.WriteString(element + "\n")
        }
        fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    }
    resolvConfig(rSwitch)
}

func ConfigChangeMac() {
    if _, err := exec.LookPath("macchanger"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install macchanger'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }
    content := `# Generated by africana-framework. Delete at your own risk!!
[Unit]
Description=changes mac for %I
Wants=network.target
Before=network.target
BindsTo=sys-subsystem-net-devices-%i.device
After=sys-subsystem-net-devices-%i.device
[Service]
Type=oneshot
ExecStart=/usr/bin/macchanger -r %I
RemainAfterExit=yes
[Install]
WantedBy=multi-.target
`
    filePath := "/etc/systemd/system/changemac@.service"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        err = ioutil.WriteFile(filePath, []byte(content), os.ModePerm)
        if err != nil {
            fmt.Printf("Error writing to file:", err)
            return
        }
    }
}

func configDhclient() {
    if _, err := exec.LookPath("dhclient"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install isc-dhcp-client isc-dhcp-server'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }
    filePath := "/etc/dhcp/dhclient.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/dhcp/dhclient.conf /etc/dhcp/dhclient.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/dhcp/dhclient.conf": {
                "#prepend domain-name-servers 127.0.0.1;": "prepend domain-name-servers 127.0.0.1, 1.1.1.1, 1.0.0.1, 8.8.8.8, 8.8.4.4;",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configDnsmasq() {
    if _, err := exec.LookPath("dnsmasq"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install dnsmasq'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }
    filePath := "/etc/dnsmasq.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/dnsmasq.conf /etc/dnsmasq.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/dnsmasq.conf": {
                "#port=5353": "port=5353",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configPrivoxy() {
    if _, err := exec.LookPath("privoxy"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install privoxy'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }
    filePath := "/etc/privoxy/privoxy.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/privoxy/config /etc/privoxy/privoxy.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/privoxy/config": {
                "#debug     1": "debug   1",
                "#debug     2": "debug   2",
                "#debug  1024": "debug   1024",
                "#debug  4096": "debug   4096",
                "#        forward-socks5t   /               127.0.0.1:9050 .": "forward-socks5t   /               127.0.0.1:9050 .",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configSquid() {
    if _, err := exec.LookPath("squid"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install squid'%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }
    filePath := "/etc/squid/squid.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/squid/squid.conf /etc/squid/squid.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/squid/squid.conf": {
                "http_port 3128": "http_port 3129\nnever_direct allow all\nshutdown_lifetime 0 seconds\ncache_peer localhost parent 8118 7 no-digest no-query",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func iP() string {
    resp, err := http.Get("https://ifconfig.me")
    if err != nil {
        resp, err = http.Get("https://ipinfo.io/ip")
        if err != nil {
            fmt.Printf("\n%s\n", err)
            fmt.Println(bcolors.Colors() + "\nSorry, can't fetch the details.\nEither the site's down or something's up with your internet configuration.\nYou may find the solution here :)\nhttps://github.com/Feliz-SZK/Linux-Decoded/blob/master/Fix%20temporary%20failure%20in%20name%20resolution.md" + bcolors.ENDC)
            //os.Exit(1)
        }
    }
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)
    return string(body)
}

func flaG() string {
    cmd := exec.Command("iptables", "-t", "nat", "-L", "-n")
    output, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Printf("\n%sencountered some hiccups while checking the iptables details%s\n", bcolors.RED, bcolors.ENDC)
    }
    return string(output)
}

func cypheR(backoff int, resolvSwitch int) int {
    if backoff > 5 {
        fmt.Printf("\n%sExceeded number of retries, terminating to prevent memory corruption.%s\n", bcolors.RED, bcolors.ENDC)
        //os.Exit(1)
    }

    if _, err := os.Stat("/etc/resolv.conf"); os.IsNotExist(err) {
        fmt.Printf("\n%sresolv.conf file is missing, %syou want me to manually create it for you? %sY/N: %s", bcolors.BLUE, bcolors.BLUE, bcolors.GREEN, bcolors.ENDC)
        var askin string
        fmt.Scanln(&askin)
        if strings.ToLower(askin) == "y" {
            file, err := os.Create("/etc/resolv.conf")
            if err != nil {
                fmt.Printf("%ssomething's wrong, can't write the file.%s\n%s", bcolors.RED, bcolors.ENDC, err)
                //os.Exit(1)
            }
            defer file.Close()
            file.WriteString("# Generated by africana-framework. Delete at your own risk!!\nnameserver 127.0.0.1\nnameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4")
            resolvSwitch++
            fmt.Printf("%sDone, saved with local DNS.%s\n", bcolors.Colors(), bcolors.ENDC)
        } else if strings.ToLower(askin) == "n" {
            fmt.Printf("%sRoger that, terminating ...%s\n", bcolors.GREEN, bcolors.ENDC)
            //os.Exit(1)
        } else {
            backoff++
            return cypheR(backoff, resolvSwitch)
        }
    }
    return resolvSwitch
}

func resolvConfig(rSwitch int) int {
    resolvString := "# Generated by africana-framework. Delete at your own risk!!\nnameserver 127.0.0.1\nnameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4"
    if rSwitch == 0 {
        file, err := os.Open("/etc/resolv.conf")
        if err != nil {
            fmt.Printf("%s\n", err)
            //os.Exit(1)
        }
        defer file.Close()

        scanner := bufio.NewScanner(file)
        found := false
        for scanner.Scan() {
            if strings.Contains(scanner.Text(), resolvString) {
                found = true
                break
            }
        }

        if !found {
            fmt.Println(bcolors.BLUE + "(" + bcolors.ORANGE + "Configuring resolv.conf.." + bcolors.ENDC)
            time.Sleep(400 * time.Millisecond)
            cmd := exec.Command("cp", "/etc/resolv.conf", "/etc/resolv.conf.backup_anonsurf")
            cmd.Run()
            file, err := os.Create("/etc/resolv.conf")
            if err != nil {
                fmt.Printf("%s\n", err)
                //os.Exit(1)
            }
            defer file.Close()
            file.WriteString(resolvString + "\n")
            fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
        } else {
            fmt.Println(bcolors.GREEN + bcolors.BOLD + "Configuring resolv.conf" + bcolors.ENDC)
            time.Sleep(400 * time.Millisecond)
            fmt.Println(bcolors.Colors() + bcolors.BOLD + " :) Already Configured" + bcolors.ENDC)
            time.Sleep(500 * time.Millisecond)
        }
    } else {
        fmt.Println(bcolors.GREEN + bcolors.BOLD + "Configuring resolv.conf" + bcolors.ENDC)
        time.Sleep(400 * time.Millisecond)
        fmt.Println(bcolors.Colors() + " :) Already Configured" + bcolors.ENDC)
    }
    return 0
}

func termiNate() {
    trigger := 0
    if _, err := os.Stat("/etc/resolv.conf.backup_anonsurf"); err == nil {
        trigger++
        cmd := exec.Command("mv", "/etc/resolv.conf.backup_anonsurf", "/etc/resolv.conf")
        cmd.Stdin = strings.NewReader("yes\n")
        cmd.Run()
        fmt.Print(bcolors.BLUE + "\n(" + bcolors.ORANGE + "Reverting to default resolv.conf..\n" + bcolors.ENDC)
        time.Sleep(500 * time.Millisecond)
        fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    }

    if _, err := os.Stat("/etc/tor/torrc.bak_anonsurf"); err == nil {
        trigger++
        cmd := exec.Command("mv", "/etc/tor/torrc.bak_anonsurf", "/etc/tor/torrc")
        cmd.Stdin = strings.NewReader("yes\n")
        cmd.Run()
        fmt.Print(bcolors.BLUE + "(" + bcolors.ORANGE + "Dropping torrc file & restoring default..\n" + bcolors.ENDC)
        time.Sleep(500 * time.Millisecond)
        fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    }

    if strings.Contains(flaG(), "anonsurf") {
        trigger++
        fmt.Print(bcolors.BLUE + "(" + bcolors.ORANGE + "Restoring Default Iptables rules..\n" + bcolors.ENDC)
        if _, err := os.Stat("/etc/iptables_rules_anonsurf.bak"); err == nil {
            cmd := exec.Command("iptables-restore", "<", "/etc/iptables_rules_anonsurf.bak")
            cmd.Run()
            os.Remove("/etc/iptables_rules_anonsurf.bak")
        } else {
            resetToDefault(true, true)
        }
        time.Sleep(1 * time.Second)
    }

    if trigger == 0 {
        fmt.Printf("\n%s%sNo instances of anonsurf have been executed%s\n", bcolors.RED, bcolors.BOLD, bcolors.ENDC)
        fmt.Printf("%s%s[Exiting ...]%s\n", bcolors.GREEN, bcolors.BOLD, bcolors.ENDC)
        //os.Exit(1)
    } else {
        fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    }
    fmt.Print(bcolors.BLUE + "(" + bcolors.ORANGE + "Stoping macchanger, dnsmasq, privoxy, squid..\n" + bcolors.ENDC)
    subprocess.Popen(`systemctl stop changemac@eth0.service dnsmasq.service squid.service privoxy.service tor@default.service`)
    fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
}

func torCircuit() {
    if !strings.Contains(flaG(), "anonsurf") {
        fmt.Printf("\n%sYou gotta start anonsurf first%s\n", bcolors.Colors(), bcolors.ENDC)
        //os.Exit(1)
    }
    exec.Command("service", "tor", "reload").Run()
    fmt.Println(bcolors.GREEN + "\nScrambling Tor Nodes" + bcolors.ENDC)
    time.Sleep(400 * time.Millisecond)
    fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    time.Sleep(400 * time.Millisecond)
    fmt.Printf("%sYour new IP appears to be: %s%s%s\n", bcolors.GREEN, bcolors.ENDC, bcolors.Colors(), bcolors.BOLD, iP())
}

func torStatus(Timer float64) {
    fmt.Print(bcolors.DARKGREEN + "Confarming if your system is secure ...\n" + bcolors.ENDC)
    resp, err := http.Get("https://check.torproject.org")
    if err != nil {
        Timer++
        if Timer > 2 {
            fmt.Println(bcolors.RED + "\nUnable to get network details, " + bcolors.ORANGE + "Check Internet Connections & " + bcolors.CYAN + "retry ...\n" + bcolors.ENDC)
            fmt.Println(bcolors.RED + "Error:" + bcolors.DARKCYAN, err, bcolors.ENDC)
            fmt.Println()
            return
        }
        fmt.Println(bcolors.GREEN + "\nHaving trouble fetching exit-node details,     " + bcolors.CYAN + "retrying ..." + bcolors.ENDC)
        time.Sleep(9 * time.Second)
        torStatus(Timer)
        return
    }
    defer resp.Body.Close()

    body, _ := ioutil.ReadAll(resp.Body)
    title := regexp.MustCompile(`<title[^>]*>([^<]+)</title>`).FindStringSubmatch(string(body))[1]
    ip := regexp.MustCompile(`[0-9]+(?:\.[0-9]+){3}`).FindString(string(body))

    fmt.Printf("\nYour IP address is: %s%s%s%s\n", bcolors.Colors(), bcolors.BOLD, ip, bcolors.ENDC)
    if strings.Contains(title, "Congratulations") {
        fmt.Printf("%sCongratulations, you're using Tor :)%s\n", bcolors.Colors(), bcolors.ENDC)
    } else {
        fmt.Printf("%s%s%s\n", bcolors.Colors(), strings.TrimSpace(title), bcolors.ENDC)
    }
}

func checkDefaultRules() (string, string) {
    cmd := exec.Command(`iptables-save | grep '^\-' | wc -l`)
    output, err := cmd.CombinedOutput()
    if err != nil {
        return "", string(output)
    }
    return string(output), ""
}

func configFirewall() {
    fmt.Print(bcolors.BLUE + "(" + bcolors.ORANGE + "Backing up Iptables..\n" + bcolors.ENDC)
    firewallGreen, firewallRed := checkDefaultRules()
    if firewallRed != "" {
        fmt.Printf("%s\nCan't execute %siptables-save%s. See the reason below.\n%s%s%s\n", bcolors.RED, bcolors.BLUE, bcolors.ENDC, bcolors.RED, firewallRed, bcolors.ENDC)
        //os.Exit(1)
    }
    if strings.TrimSpace(firewallGreen) == "0" {
        fmt.Printf(" %sDefault rules are configured, skipping..%s\n", bcolors.BLUE, bcolors.ENDC)
    } else {
        cmd := exec.Command("iptables-save", ">", "/etc/iptables_rules_anonsurf.bak")
        cmd.Run()
        fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")\n" + bcolors.ENDC)
    }

    innOutRules := `
### Set variables
# The UID that Tor runs as (varies from system to system)

_tor_uid=$(id -u debian-tor) #Debian/Ubuntu

# Tor's TransPort
_trans_port="9040"

# Tor's DNSPort
_dns_port="5353"

# Tor's VirtualAddrNetworkIPv4
_virt_addr="10.192.0.0/10"

# LAN destinations that shouldn't be routed through Tor
_non_tor="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"

# Other IANA reserved blocks (These are not processed by tor and dropped by default)
_resv_iana="0.0.0.0/8 100.64.0.0/10 169.254.0.0/16 192.0.0.0/24 192.0.2.0/24 192.88.99.0/24 198.18.0.0/15 198.51.100.0/24 203.0.113.0/24 224.0.0.0/4 240.0.0.0/4 255.255.255.255/32"

# Flushing existing Iptables Chains/Firewall rules #
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT

iptables -F
iptables -X
iptables -Z

iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X

### *nat OUTPUT (For local redirection)
# nat .onion addresses
iptables -t nat -A OUTPUT -d $_virt_addr -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j REDIRECT --to-ports $_trans_port

# nat dns requests to Tor
iptables -t nat -A OUTPUT -d 127.0.0.1/32 -p udp -m udp --dport 53 -j REDIRECT --to-ports $_dns_port -m comment --comment "anonsurf_triggered"

# Don't nat the Tor process, the loopback, or the local network
iptables -t nat -A OUTPUT -m owner --uid-owner $_tor_uid -j RETURN
iptables -t nat -A OUTPUT -o lo -j RETURN

# Allow lan access for hosts in $_non_tor and $_resv_ina
# This is to make sure that this local addresses don't get dropped.
for _lan in $_non_tor; do
  iptables -t nat -A OUTPUT -d $_lan -j RETURN
done

for _iana in $_resv_iana; do
  iptables -t nat -A OUTPUT -d $_iana -j RETURN
done

# Redirect all other pre-routing and output to Tor's TransPort
iptables -t nat -A OUTPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j REDIRECT --to-ports $_trans_port

### *filter INPUT
iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT

# Log & Drop everything else. Uncomment to enable logging
#iptables -A INPUT -j LOG --log-prefix "Dropped INPUT packet: " --log-level 7 --log-uid
iptables -A INPUT -j DROP

### *filter FORWARD
iptables -A FORWARD -j DROP

### Fix for possible kernel packet-leak as discussed in,
### https://lists.torproject.org/pipermail/tor-talk/2014-March/032507.html
### uncomment below lines to log dropped packets

iptables -A OUTPUT -m conntrack --ctstate INVALID -j DROP
# iptables -A OUTPUT -m state --state INVALID -j LOG --log-prefix "Transproxy state leak blocked: " --log-uid
iptables -A OUTPUT -m state --state INVALID -j DROP

### *filter OUTPUT
iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT

# Allow Tor process output
iptables -A OUTPUT -m owner --uid-owner $_tor_uid -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -j ACCEPT

# Allow loopback output
iptables -A OUTPUT -d 127.0.0.1/32 -o lo -j ACCEPT

# Tor transproxy magic
iptables -A OUTPUT -d 127.0.0.1/32 -p tcp -m tcp --dport $_trans_port --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT

# Drop everything else.
iptables -A OUTPUT -j DROP

### Set default policies to DROP
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP
`
    fmt.Print(bcolors.BLUE + "(" + bcolors.ORANGE + "Setting up firewall rules..\n" + bcolors.ENDC)
    cmd := exec.Command("/bin/bash", "-c", innOutRules)
    cmd.Run()
    fmt.Print("                                                    " + bcolors.GREEN + "Done " + bcolors.ORANGE + "✔" + bcolors.BLUE +")" + bcolors.ENDC)
}

func resetToDefault(overidePass bool, resetAsChildFunc bool) {
    var resetTrigger int
    if !overidePass {
        if resetTrigger > 7 {
            fmt.Printf("%sexiting to prevent memory corruption.%s\n", bcolors.RED, bcolors.ENDC)
            //os.Exit(1)
        }
        var resetConsent string
        fmt.Printf("%s\nThis will overwrite all of your existing rules %sY(do it)%s/%sN(exit)%s: ", bcolors.Colors(), bcolors.GREEN, bcolors.ENDC, bcolors.RED, bcolors.ENDC)
        fmt.Scanln(&resetConsent)
        if strings.ToLower(resetConsent) == "y" {
            //continue
        } else if strings.ToLower(resetConsent) == "n" {
            fmt.Printf("%sCopy that..\n%s", bcolors.RED, bcolors.ENDC)
            //os.Exit(1)
        } else {
            resetTrigger++
            resetToDefault(overidePass, resetAsChildFunc)
            return
        }

        time.Sleep(1 * time.Second)
        fmt.Printf("%sBacking up current rules, just in case..%s\n", bcolors.PURPLE, bcolors.ENDC)

        defaultCheckOne, defaultCheckNeo := checkDefaultRules()
        if defaultCheckNeo != "" {
            fmt.Printf("%sError while checking existing rules; %sexiting..\n%sError message: %s%s%s\n", bcolors.RED, bcolors.ORANGE, bcolors.YELLOW, bcolors.Colors(), defaultCheckNeo, bcolors.ENDC)
            //os.Exit(1)
        }
        if strings.TrimSpace(defaultCheckOne) != "0" {
            fileNameID := time.Now().Format("01_02_2006-15:04:05")
            cmd := exec.Command("sudo", "iptables-save", ">", "/tmp/iptables_"+fileNameID+".rules")
            cmd.Run()
            fmt.Printf("%sSaved in %s/tmp%s as %siptables_%s.rules%s\n\n", bcolors.CYAN, bcolors.BLUE, bcolors.ENDC, bcolors.RED, fileNameID, bcolors.ENDC)
        } else {
            fmt.Printf("%s Default rules are set, backup not required :)%s\n", bcolors.ORANGE, bcolors.ENDC)
        }
        fmt.Printf("%s%sResetting Iptables%s\n", bcolors.ORANGE, bcolors.BOLD, bcolors.ENDC)
    }
    iptablesRules := `
# Accepting all traffic first#
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT

# Flushing All Iptables Chains/Firewall rules #
iptables -F

# Deleting all Iptables Chains #
iptables -X

# Flushing all counters too #
iptables -Z
# Flush and delete all nat and  mangle #
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
`
    cmd := exec.Command("/bin/bash", "-c", iptablesRules)
    output, err := cmd.CombinedOutput()
    time.Sleep(500 * time.Millisecond)
    if err != nil {
        fmt.Printf("%sCan't reset Iptables%s\n", bcolors.Colors(), bcolors.ENDC)
        fmt.Printf("%s%s%s\n", bcolors.Colors(), string(output), bcolors.ENDC)
        //os.Exit(1)
    }
    if !resetAsChildFunc {
        fmt.Printf("%s Successfully reset Iptables to default :)%s\n", bcolors.BLUE, bcolors.ENDC)
    }
}


