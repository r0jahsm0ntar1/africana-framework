//John 3:16

package securities

import(
    "os"
    "fmt"
    "time"
    "bufio"
    "utils"
    "menus"
    "regexp"
    "banners"
    "strconv"
    "strings"
    "bcolors"
    "os/exec"
    "net/http"
    "io/ioutil"
    "subprocess"
    "scriptures"
)

var (
    LHostIp, _ = utils.GetDefaultIP()
    scanner   = bufio.NewScanner(os.Stdin)
    Input, RHost, Proxy, Script, Function string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, RokyPath, WordListDir = utils.DirLocations()
)

type stringMatcher struct {
    names  []string
    action func()
}

var torrString = []string{
    "# Generated by africana-framework. Delete at your own risk!\n",
    "VirtualAddrNetwork 10.192.0.0/10",
    "AutomapHostsOnResolve 1",
    "CookieAuthentication 1",
    "TransPort 9040",
    "SocksPort 9050",
    "DNSPort 5353",
}

func Torsocks() {
    for {
        fmt.Printf("%s%safr3%s torsocks(%s%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Underl, bcolors.Bold, bcolors.Endc, bcolors.Bold, bcolors.BrightRed, Function, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        scanner.Scan()
        Input = strings.TrimSpace(scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandGroups := []stringMatcher{

        {[]string{"? info", "h info", "help info"}, menus.HelpInfo},
        {[]string{"v", "version"}, banners.Version},
        {[]string{"s", "sleep"}, utils.Sleep},
        {[]string{"c", "cls", "clear", "cls screen", "clear screen", "screen cls", "screen clear"}, utils.ClearScreen},

        {[]string{"histo", "history", "show history", "log", "logs", "show log", "show logs"}, subprocess.ShowHistory},
        {[]string{"c junk", "c junks", "c output", "c outputs", "clear junk", "clear junks", "clear output", "clear outputs"}, utils.ClearJunks},
        {[]string{"c log", "c logs", "c history", "c histories", "clear log", "clear logs", "clear history", "clear histories"}, subprocess.ClearHistory},
        {[]string{"junk", "junks", "output", "outputs", "show junk", "show junks", "show output", "show outputs", "l junk", "l junks", "l output", "l outputs", "list junk", "list junks", "list output", "list outputs"}, utils.ListJunks},

        {[]string{"? run", "h run", "info run", "help run", "? exec", "h exec", "info exec", "help exec", "? launch", "h launch", "info launch", "help launch", "? exploit", "h exploit", "info exploit", "help exploit", "? execute", "h execute", "info execute", "help execute"}, menus.HelpInfoRun},

        {[]string{"set", "h set", "info set", "help set"}, menus.HelpInfoSet},
        {[]string{"use", "? use", "h use", "info use", "help use"}, menus.HelpInfoUse},

        {[]string{"tips", "h tips", "? tips", "info tips", "help tips"}, menus.HelpInfoTips},
        {[]string{"show", "? show", "h show", "info show", "help show"}, menus.HelpInfoShow},
        {[]string{"info list", "help list", "use list", "list"}, menus.HelpInfoList},
        {[]string{"h option", "? option", "h options", "? options", "info option", "help option", "info options", "help options"}, menus.HelpInfOptions},
        {[]string{"banner"}, banners.RandomBanners},
        {[]string{"g", "t", "guide", "tutarial"}, utils.BrowseTutarilas},
        {[]string{"h", "?", "00", "help"}, menus.HelpInfoMenuZero},
        {[]string{"f", "use f", "features", "use features"}, menus.HelpInfoFeatures},

        {[]string{"info"}, menus.HelpInfoTorsocks},
        {[]string{"m", "menu"}, menus.MenuTwo},
        {[]string{"option", "options", "show option", "show options"}, menus.TorsocksOptions},
        {[]string{"func", "funcs", "functions", "show func", "list funcs", "show funcs", "show function", "list function", "list functions", "show functions", "module", "modules", "list module", "show module", "list modules", "show modules", "show all", "list all"}, menus.ListTorsocksFunctions},

        {[]string{"1", "run 1", "use 1", "exec 1", "start 1", "launch 1", "exploit 1", "execute 1", "run setups", "use setups", "exec setups", "start setups", "launch setups", "exploit setups", "execute setups"}, func() { AnonimityFunctions("setups") }},
        {[]string{"? 1", "info 1", "help 1", "setups", "info setups", "help setups"}, menus.HelpInfoTorsocksSetups},

        {[]string{"2", "run 2", "use 2", "exec 2", "start 2", "launch 2", "exploit 2", "execute 2", "run vanish", "use vanish", "exec vanish", "start vanish", "launch vanish", "exploit vanish", "execute vanish"}, func() { AnonimityFunctions("vanish") }},
        {[]string{"? 2", "info 2", "help 2", "vanish", "info vanish", "help vanish"}, menus.HelpInfoTorsocksVanish},

        {[]string{"3", "run 3", "use 3", "exec 3", "start 3", "launch 3", "exploit 3", "execute 3", "run status", "use status", "exec status", "start status", "launch status", "exploit status", "execute status"}, func() { AnonimityFunctions("status") }},
        {[]string{"? 3", "info 3", "help 3", "status", "info status", "help status"}, menus.HelpInfoTorsocksStatus},

        {[]string{"4", "run 4", "use 4", "exec 4", "start 4", "launch 4", "exploit 4", "execute 4", "run torip", "use torip", "exec torip", "start torip", "launch torip", "exploit torip", "execute torip"}, func() { AnonimityFunctions("torip") }},
        {[]string{"? 4", "info 4", "help 4", "torip", "info torip", "help torip"}, menus.HelpInfoTorsocksTorIp},

        {[]string{"5", "run 5", "use 5", "exec 5", "start 5", "launch 5", "exploit 5", "execute 5", "run chains", "use chains", "exec chains", "start chains", "launch chains", "exploit chains", "execute chains"}, func() { AnonimityFunctions("chains") }},
        {[]string{"? 5", "info 5", "help 5", "chains", "info chains", "help chains"}, menus.HelpInfoTorsocksChains},

        {[]string{"6", "run 6", "use 6", "exec 6", "start 6", "launch 6", "exploit 6", "execute 6", "run reload", "use reload", "exec reload", "start reload", "launch reload", "exploit reload", "execute reload"}, func() { AnonimityFunctions("reload") }},
        {[]string{"? 6", "info 6", "help 6", "reload", "info reload", "help reload"}, menus.HelpInfoTorsocksReload},

        {[]string{"7", "run 7", "use 7", "exec 7", "start 7", "launch 7", "exploit 7", "execute 7", "run exitnode", "use exitnode", "exec exitnode", "start exitnode", "launch exitnode", "exploit exitnode", "execute exitnode"}, func() { AnonimityFunctions("exitnode") }},
        {[]string{"? 7", "info 7", "help 7", "exitnode", "info exitnode", "help exitnode"}, menus.HelpInfoTorsocksExitnode},

        {[]string{"8", "run 8", "use 8", "exec 8", "start 8", "launch 8", "exploit 8", "execute 8", "run restore", "use restore", "exec restore", "start restore", "launch restore", "exploit restore", "execute restore"}, func() { AnonimityFunctions("restore") }},
        {[]string{"? 8", "info 8", "help 8", "restore", "info restore", "help restore"}, menus.HelpInfoTorsocksRestore},

        {[]string{"9", "run 9", "use 9", "exec 9", "start 9", "launch 9", "exploit 9", "execute 9", "run stop", "use stop", "exec stop", "start stop", "launch stop", "exploit stop", "execute stop"}, func() { AnonimityFunctions("stop") }},
        {[]string{"? 9", "info 9", "help 9", "stop", "info stop", "help stop"}, menus.HelpInfoTorsocksStop}, 

        {[]string{"10", "run 10", "use 10", "exec 10", "start 10", "launch 10", "exploit 10", "execute 10", "run verses", "use verses", "exec verses", "start verses", "launch verses", "exploit verses", "execute verses"}, scriptures.ScriptureNarators},
        {[]string{"? 10", "verses", "info 10", "help 10", "info verses", "help verses"}, menus.HelpInfoVerses},
    }

    cmdLower := strings.ToLower(cmd)
    for _, group := range commandGroups {
        for _, name := range group.names {
            if name == cmdLower {
                group.action()
                return true
            }
        }
    }
    return false
} 

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{
        "proxies": &Proxy,
        "func": &Function,
        "funcs": &Function,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "functions": &Function,
    }

    validKeys := make([]string, 0, len(setValues))
    for k := range setValues {
        validKeys = append(validKeys, k)
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
        return
    }

    var suggestions []string
    lowerInput := strings.ToLower(key)
    for _, cmd := range validKeys {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            suggestions = append(suggestions, cmd)
        }
    }

    if len(suggestions) > 0 {
        fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Did you mean one of these?%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

        maxWidth := 0
        for _, s := range suggestions {
            if len(s) > maxWidth {
                maxWidth = len(s)
            }
        }
        maxWidth += 3

        cols := 5
        if len(suggestions) < cols {
            cols = len(suggestions)
        }

        for i := 0; i < len(suggestions); i += cols {
            for j := 0; j < cols && i+j < len(suggestions); j++ {
                fmt.Printf(" - %s%-*s%s", bcolors.Green, maxWidth, suggestions[i+j], bcolors.Endc)
            }
            fmt.Println()
        }

        return
    }

    fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Available keys:%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)
    maxWidth := 0
    for _, k := range validKeys {
        if len(k) > maxWidth {
            maxWidth = len(k)
        }
    }
    maxWidth += 3

    cols := 5
    for i := 0; i < len(validKeys); i += cols {
        for j := 0; j < cols && i+j < len(validKeys); j++ {
            fmt.Printf(" - %s%-*s%s", bcolors.Green, maxWidth, validKeys[i+j], bcolors.Endc)
        }
        fmt.Println()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{
        "proxies": &Proxy,
        "func": &Function,
        "funcs": &Function,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "functions": &Function,
    }
    defaultValues := map[string]string{
        "func":      "",
        "proxies":   "",
        "funcs":     "",
        "module":    "",
        "output":    "",
        "function":  "",
        "functions": "",
    }

    validKeys := make([]string, 0, len(unsetValues))
    for k := range unsetValues {
        validKeys = append(validKeys, k)
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key]
        fmt.Printf("%s => %s\n", strings.ToUpper(key), "Null")
        return
    }

    var suggestions []string
    lowerInput := strings.ToLower(key)
    for _, cmd := range validKeys {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            suggestions = append(suggestions, cmd)
        }
    }

    if len(suggestions) > 0 {
        fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Did you mean one of these?%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

        maxWidth := 0
        for _, s := range suggestions {
            if len(s) > maxWidth {
                maxWidth = len(s)
            }
        }
        maxWidth += 3

        cols := 5
        if len(suggestions) < cols {
            cols = len(suggestions)
        }
        
        for i := 0; i < len(suggestions); i += cols {
            for j := 0; j < cols && i+j < len(suggestions); j++ {
                fmt.Printf(" - %s%-*s%s", bcolors.Green, maxWidth, suggestions[i+j], bcolors.Endc)
            }
            fmt.Println()
        }

        return
    }

    fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Available keys:%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

    maxWidth := 0
    for _, k := range validKeys {
        if len(k) > maxWidth {
            maxWidth = len(k)
        }
    }
    maxWidth += 3

    cols := 5
    for i := 0; i < len(validKeys); i += cols {
        for j := 0; j < cols && i+j < len(validKeys); j++ {
            fmt.Printf(" - %s%-*s%s", bcolors.Green, maxWidth, validKeys[i+j], bcolors.Endc)
        }
        fmt.Println()
    }
}

func executeFunction() {
    if Function == ""{
        fmt.Printf("\n%s[!] %sNo MODULE was set. Use %s'show modules' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    AnonimityFunctions(Function)
}

func AnonimityFunctions(Function string, args ...interface{}) {
    fmt.Printf("\nFunction => %s\n", Function)
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        if err := utils.SetProxy(Proxy); err != nil {
            //
        }
    }

    commands := map[string]func(){
        "setups": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`apt-get update; apt-get install -y tor squid privoxy dnsmasq iptables isc-dhcp-client isc-dhcp-server`); fmt.Println()},
        "start": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configDhclient(); ConfigChangeMac(); configDnsmasq(); configSquid(); configPrivoxy(); configFirewall(); torStatus(0)},
        "status": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`systemctl --no-pager -l status changemac@eth0.service dnsmasq.service squid.service privoxy.service tor@default.service`); fmt.Println()},
        "exitnode": func() {banners.GraphicsTorNet(); fmt.Println(); torCircuit()},
        "torip": func() {banners.GraphicsTorNet(); fmt.Println(); torStatus(0)},
        "restore": func() {banners.GraphicsTorNet(); fmt.Println(); resetToDefault(false, false)},
        "chains": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`tail -vf /var/log/privoxy/logfile`); fmt.Println()},
        "reload": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configFirewall(); torStatus(0)},
        "stop": func() {banners.GraphicsTorNet(); fmt.Println(); termiNate()},

        "1": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`apt-get update; apt-get install -y tor squid privoxy dnsmasq iptables isc-dhcp-client isc-dhcp-server`); fmt.Println()},
        "2": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configDhclient(); ConfigChangeMac(); configDnsmasq(); configSquid(); configPrivoxy(); configFirewall(); torStatus(0)},
        "3": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`systemctl --no-pager -l status changemac@eth0.service dnsmasq.service squid.service privoxy.service tor@default.service`); fmt.Println()},
        "4": func() {banners.GraphicsTorNet(); fmt.Println(); torCircuit()},
        "5": func() {banners.GraphicsTorNet(); fmt.Println(); torStatus(0)},
        "6": func() {banners.GraphicsTorNet(); fmt.Println(); resetToDefault(false, false)},
        "7": func() {banners.GraphicsTorNet(); fmt.Println(); subprocess.Popen(`tail -vf /var/log/privoxy/logfile`); fmt.Println()},
        "8": func() {banners.GraphicsTorNet(); fmt.Println(); configTorrc(); configFirewall(); torStatus(0)},
        "9": func() {banners.GraphicsTorNet(); fmt.Println(); termiNate()},
    }

    textCommands := []string{"setups", "start", "status", "exitnode", "torip", "restore", "chains", "reload", "stop"}

    if action, exists := commands[Function]; exists {
        action()
        return
    }

    if num, err := strconv.Atoi(Function); err == nil {
        fmt.Printf("\n%s[!] %sNumber %d is invalid. Valid numbers are from 1-10.\n", bcolors.Yellow, bcolors.Endc, num)
        menus.ListTorsocksFunctions()
        return
    }

    lowerInput := strings.ToLower(Function)
    for _, cmd := range textCommands {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            fmt.Printf("\n%s[!] %sFunction '%s%s%s' is invalid. Did you mean %s'%s'%s?\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, Function, bcolors.Endc, bcolors.Green, cmd, bcolors.Endc)
            return
        }
    }

    fmt.Printf("\n%s[!] %sModule '%s' is invalid. Available commands:\n", bcolors.Yellow, bcolors.Endc, Function)
    menus.ListTorsocksFunctions()
}

func configTorrc() {
    if strings.Contains(flaG(), "torsocks") {
        fmt.Print(bcolors.Cyan + "\n              Torsocks: " + bcolors.Endc + "is already running ...\n" + bcolors.Endc)
        //os.Exit(1)
    }

    rSwitch := cypheR(0, 0)

    if _, err := exec.LookPath("tor"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install tor'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }

    if _, err := os.Stat("/etc/tor/torrc"); os.IsNotExist(err) {
        fmt.Printf("%sNo torrc file is configured ...%s%sConfiguring:)%s\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        file, err := os.Create("/etc/tor/torrc")
        if err != nil {
            fmt.Printf("%sFailed to write the torrc file%s \n %s", bcolors.BrightRed, bcolors.Endc, err)
            //os.Exit(1)
        }
        defer file.Close()
        for _, element := range torrString {
            file.WriteString(element + "\n")
        }
        fmt.Printf("%sDone ...%s\n", bcolors.BrightCyan, bcolors.Endc)
    } else {
        fmt.Println(bcolors.BrightBlue + "\n(" + bcolors.BrightYellow + "Configuring Torrc ..." + bcolors.Endc)
        time.Sleep(400 * time.Millisecond)
        cmd := exec.Command("cp", "/etc/tor/torrc", "/etc/tor/torrc.bak_torsocks")
        cmd.Run()
        file, err := os.Create("/etc/tor/torrc")
        if err != nil {
            fmt.Printf("%s\n", err)
            //os.Exit(1)
        }
        defer file.Close()
        for _, element := range torrString {
            file.WriteString(element + "\n")
        }
        fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    }
    resolvConfig(rSwitch)
}

func ConfigChangeMac() {
    if _, err := exec.LookPath("macchanger"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install macchanger'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }
    content := `# Generated by africana-framework. Delete at your own risk!!
[Unit]
Description=changes mac for %I
Wants=network.target
Before=network.target
BindsTo=sys-subsystem-net-devices-%i.device
After=sys-subsystem-net-devices-%i.device
[Service]
Type=oneshot
ExecStart=/usr/bin/macchanger -r %I
RemainAfterExit=yes
[Install]
WantedBy=multi-.target
`
    filePath := "/etc/systemd/system/changemac@.service"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        err = ioutil.WriteFile(filePath, []byte(content), os.ModePerm)
        if err != nil {
            fmt.Printf("Error writing to file:", err)
            return
        }
    }
}

func configDhclient() {
    if _, err := exec.LookPath("dhclient"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install isc-dhcp-client isc-dhcp-server'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }
    filePath := "/etc/dhcp/dhclient.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/dhcp/dhclient.conf /etc/dhcp/dhclient.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/dhcp/dhclient.conf": {
                "#prepend domain-name-servers 127.0.0.1;": "prepend domain-name-servers 127.0.0.1, 1.1.1.1, 1.0.0.1, 8.8.8.8, 8.8.4.4;",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configDnsmasq() {
    if _, err := exec.LookPath("dnsmasq"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install dnsmasq'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }
    filePath := "/etc/dnsmasq.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/dnsmasq.conf /etc/dnsmasq.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/dnsmasq.conf": {
                "#port=5353": "port=5353",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configPrivoxy() {
    if _, err := exec.LookPath("privoxy"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install privoxy'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }
    filePath := "/etc/privoxy/privoxy.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/privoxy/config /etc/privoxy/privoxy.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/privoxy/config": {
                "#debug     1": "debug   1",
                "#debug     2": "debug   2",
                "#debug  1024": "debug   1024",
                "#debug  4096": "debug   4096",
                "#        forward-socks5t   /               127.0.0.1:9050 .": "forward-socks5t   /               127.0.0.1:9050 .",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func configSquid() {
    if _, err := exec.LookPath("squid"); err != nil {
        fmt.Printf("\n%sTor isn't installed, install it with 'sudo apt install squid'%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }
    filePath := "/etc/squid/squid.conf.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`cp -r /etc/squid/squid.conf /etc/squid/squid.conf.bak_africana`)
        filesToReplacements := map[string]map[string]string{
            "/etc/squid/squid.conf": {
                "http_port 3128": "http_port 3129\nnever_direct allow all\nshutdown_lifetime 0 seconds\ncache_peer localhost parent 8118 7 no-digest no-query",
            },
        }
        utils.Editors(filesToReplacements)
    }
}

func iP() string {
    resp, err := http.Get("https://ifconfig.me")
    if err != nil {
        resp, err = http.Get("https://ipinfo.io/ip")
        if err != nil {
            fmt.Printf("\n%s\n", err)
            fmt.Println(bcolors.Colors() + "\nSorry, can't fetch the details.\nEither the site's down or something's up with your internet configuration.\nYou may find the solution here :)\nhttps://github.com/Feliz-SZK/Linux-Decoded/blob/master/Fix%20temporary%20failure%20in%20name%20resolution.md" + bcolors.Endc)
            //os.Exit(1)
        }
    }
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)
    return string(body)
}

func flaG() string {
    cmd := exec.Command("iptables", "-t", "nat", "-L", "-n")
    output, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Printf("\n%sencountered some hiccups while checking the iptables details%s\n", bcolors.BrightRed, bcolors.Endc)
    }
    return string(output)
}

func cypheR(backoff int, resolvSwitch int) int {
    if backoff > 5 {
        fmt.Printf("\n%sExceeded number of retries, terminating to prevent memory corruption.%s\n", bcolors.BrightRed, bcolors.Endc)
        //os.Exit(1)
    }

    if _, err := os.Stat("/etc/resolv.conf"); os.IsNotExist(err) {
        fmt.Printf("\n%sresolv.conf file is missing, %syou want me to manually create it for you? %sY/N: %s", bcolors.BrightBlue, bcolors.BrightBlue, bcolors.Green, bcolors.Endc)
        var askin string
        fmt.Scanln(&askin)
        if strings.ToLower(askin) == "y" {
            file, err := os.Create("/etc/resolv.conf")
            if err != nil {
                fmt.Printf("%ssomething's wrong, can't write the file.%s\n%s", bcolors.BrightRed, bcolors.Endc, err)
                //os.Exit(1)
            }
            defer file.Close()
            file.WriteString("# Generated by africana-framework. Delete at your own risk!!\nnameserver 127.0.0.1\nnameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4")
            resolvSwitch++
            fmt.Printf("%sDone, saved with local DNS.%s\n", bcolors.Colors(), bcolors.Endc)
        } else if strings.ToLower(askin) == "n" {
            fmt.Printf("%sRoger that, terminating ...%s\n", bcolors.Green, bcolors.Endc)
            //os.Exit(1)
        } else {
            backoff++
            return cypheR(backoff, resolvSwitch)
        }
    }
    return resolvSwitch
}

func resolvConfig(rSwitch int) int {
    resolvString := "# Generated by africana-framework. Delete at your own risk!!\nnameserver 127.0.0.1\nnameserver 1.1.1.1\nnameserver 1.0.0.1\nnameserver 8.8.8.8\nnameserver 8.8.4.4"
    if rSwitch == 0 {
        file, err := os.Open("/etc/resolv.conf")
        if err != nil {
            fmt.Printf("%s\n", err)
            //os.Exit(1)
        }
        defer file.Close()

        scanner := bufio.NewScanner(file)
        found := false
        for scanner.Scan() {
            if strings.Contains(scanner.Text(), resolvString) {
                found = true
                break
            }
        }

        if !found {
            fmt.Println(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Configuring resolv.conf.." + bcolors.Endc)
            time.Sleep(400 * time.Millisecond)
            cmd := exec.Command("cp", "/etc/resolv.conf", "/etc/resolv.conf.backup_torsocks")
            cmd.Run()
            file, err := os.Create("/etc/resolv.conf")
            if err != nil {
                fmt.Printf("%s\n", err)
                //os.Exit(1)
            }
            defer file.Close()
            file.WriteString(resolvString + "\n")
            fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
        } else {
            fmt.Println(bcolors.Green + bcolors.Bold + "Configuring resolv.conf" + bcolors.Endc)
            time.Sleep(400 * time.Millisecond)
            fmt.Println(bcolors.Colors() + bcolors.Bold + " :) Already Configured" + bcolors.Endc)
            time.Sleep(500 * time.Millisecond)
        }
    } else {
        fmt.Println(bcolors.Green + bcolors.Bold + "Configuring resolv.conf" + bcolors.Endc)
        time.Sleep(400 * time.Millisecond)
        fmt.Println(bcolors.Colors() + " :) Already Configured" + bcolors.Endc)
    }
    return 0
}

func termiNate() {
    trigger := 0
    if _, err := os.Stat("/etc/resolv.conf.backup_torsocks"); err == nil {
        trigger++
        cmd := exec.Command("mv", "/etc/resolv.conf.backup_torsocks", "/etc/resolv.conf")
        cmd.Stdin = strings.NewReader("yes\n")
        cmd.Run()
        fmt.Print(bcolors.BrightBlue + "\n(" + bcolors.BrightYellow + "Reverting to default resolv.conf..\n" + bcolors.Endc)
        time.Sleep(500 * time.Millisecond)
        fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    }

    if _, err := os.Stat("/etc/tor/torrc.bak_torsocks"); err == nil {
        trigger++
        cmd := exec.Command("mv", "/etc/tor/torrc.bak_torsocks", "/etc/tor/torrc")
        cmd.Stdin = strings.NewReader("yes\n")
        cmd.Run()
        fmt.Print(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Dropping torrc file & restoring default..\n" + bcolors.Endc)
        time.Sleep(500 * time.Millisecond)
        fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    }

    if strings.Contains(flaG(), "torsocks") {
        trigger++
        fmt.Print(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Restoring Default Iptables rules..\n" + bcolors.Endc)
        if _, err := os.Stat("/etc/iptables_rules_torsocks.bak"); err == nil {
            cmd := exec.Command("iptables-restore", "<", "/etc/iptables_rules_torsocks.bak")
            cmd.Run()
            os.Remove("/etc/iptables_rules_torsocks.bak")
        } else {
            resetToDefault(true, true)
        }
        time.Sleep(1 * time.Second)
    }

    if trigger == 0 {
        fmt.Printf("\n%s%sNo instances of torsocks have been executed%s\n", bcolors.BrightRed, bcolors.Bold, bcolors.Endc)
        fmt.Printf("%s%s[Exiting ...]%s\n", bcolors.Green, bcolors.Bold, bcolors.Endc)
        //os.Exit(1)
    } else {
        fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    }
    fmt.Print(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Stoping macchanger, dnsmasq, privoxy, squid..\n" + bcolors.Endc)
    subprocess.Popen(`systemctl stop changemac@eth0.service dnsmasq.service squid.service privoxy.service tor@default.service`)
    fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
}

func torCircuit() {
    if !strings.Contains(flaG(), "torsocks") {
        fmt.Printf("\n%sYou gotta start torsocks first%s\n", bcolors.Colors(), bcolors.Endc)
        //os.Exit(1)
    }
    exec.Command("service", "tor", "reload").Run()
    fmt.Println(bcolors.Green + "\nScrambling Tor Nodes" + bcolors.Endc)
    time.Sleep(400 * time.Millisecond)
    fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    time.Sleep(400 * time.Millisecond)
    fmt.Printf("%sYour new IP appears to be: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.Colors(), bcolors.Bold, iP())
}

func torStatus(Timer float64) {
    fmt.Print(bcolors.Green + "Confarming if your system is secure ...\n" + bcolors.Endc)
    resp, err := http.Get("https://check.torproject.org")
    if err != nil {
        Timer++
        if Timer > 2 {
            fmt.Println(bcolors.BrightRed + "\nUnable to get network details, " + bcolors.BrightYellow + "Check Internet Connections & " + bcolors.BrightCyan + "retry ...\n" + bcolors.Endc)
            fmt.Println(bcolors.BrightRed + "Error:" + bcolors.Cyan, err, bcolors.Endc)
            fmt.Println()
            return
        }
        fmt.Println(bcolors.Green + "\nHaving trouble fetching exit-node details,     " + bcolors.BrightCyan + "retrying ..." + bcolors.Endc)
        time.Sleep(9 * time.Second)
        torStatus(Timer)
        return
    }
    defer resp.Body.Close()

    body, _ := ioutil.ReadAll(resp.Body)
    title := regexp.MustCompile(`<title[^>]*>([^<]+)</title>`).FindStringSubmatch(string(body))[1]
    ip := regexp.MustCompile(`[0-9]+(?:\.[0-9]+){3}`).FindString(string(body))

    fmt.Printf("\nYour IP address is: %s%s%s%s\n", bcolors.Colors(), bcolors.Bold, ip, bcolors.Endc)
    if strings.Contains(title, "Congratulations") {
        fmt.Printf("%sCongratulations, you're using Tor :)%s\n", bcolors.Colors(), bcolors.Endc)
    } else {
        fmt.Printf("%s%s%s\n", bcolors.Colors(), strings.TrimSpace(title), bcolors.Endc)
    }
}

func checkDefaultRules() (string, string) {
    cmd := exec.Command(`iptables-save | grep '^\-' | wc -l`)
    output, err := cmd.CombinedOutput()
    if err != nil {
        return "", string(output)
    }
    return string(output), ""
}

func configFirewall() {
    fmt.Print(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Backing up Iptables..\n" + bcolors.Endc)
    firewallGreen, firewallRed := checkDefaultRules()
    if firewallRed != "" {
        fmt.Printf("%s\nCan't execute %siptables-save%s. See the reason below.\n%s%s%s\n", bcolors.BrightRed, bcolors.BrightBlue, bcolors.Endc, bcolors.BrightRed, firewallRed, bcolors.Endc)
        //os.Exit(1)
    }
    if strings.TrimSpace(firewallGreen) == "0" {
        fmt.Printf(" %sDefault rules are configured, skipping..%s\n", bcolors.BrightBlue, bcolors.Endc)
    } else {
        cmd := exec.Command("iptables-save", ">", "/etc/iptables_rules_torsocks.bak")
        cmd.Run()
        fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")\n" + bcolors.Endc)
    }

    innOutRules := `
### Set variables
# The UID that Tor runs as (varies from system to system)

_tor_uid=$(id -u debian-tor) #Debian/Ubuntu

# Tor's TransPort
_trans_port="9040"

# Tor's DNSPort
_dns_port="5353"

# Tor's VirtualAddrNetworkIPv4
_virt_addr="10.192.0.0/10"

# LAN destinations that shouldn't be routed through Tor
_non_tor="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"

# Other IANA reserved blocks (These are not processed by tor and dropped by default)
_resv_iana="0.0.0.0/8 100.64.0.0/10 169.254.0.0/16 192.0.0.0/24 192.0.2.0/24 192.88.10.0/24 198.18.0.0/15 198.51.100.0/24 203.0.113.0/24 224.0.0.0/4 240.0.0.0/4 255.255.255.255/32"

# Flushing existing Iptables Chains/Firewall rules #
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT

iptables -F
iptables -X
iptables -Z

iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X

### *nat OUTPUT (For local redirection)
# nat .onion addresses
iptables -t nat -A OUTPUT -d $_virt_addr -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j RedIRECT --to-ports $_trans_port

# nat dns requests to Tor
iptables -t nat -A OUTPUT -d 127.0.0.1/32 -p udp -m udp --dport 53 -j RedIRECT --to-ports $_dns_port -m comment --comment "torsocks_triggered"

# Don't nat the Tor process, the loopback, or the local network
iptables -t nat -A OUTPUT -m owner --uid-owner $_tor_uid -j RETURN
iptables -t nat -A OUTPUT -o lo -j RETURN

# Allow lan access for hosts in $_non_tor and $_resv_ina
# This is to make sure that this local addresses don't get dropped.
for _lan in $_non_tor; do
  iptables -t nat -A OUTPUT -d $_lan -j RETURN
done

for _iana in $_resv_iana; do
  iptables -t nat -A OUTPUT -d $_iana -j RETURN
done

# Redirect all other pre-routing and output to Tor's TransPort
iptables -t nat -A OUTPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j RedIRECT --to-ports $_trans_port

### *filter INPUT
iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT

# Log & Drop everything else. Uncomment to enable logging
#iptables -A INPUT -j LOG --log-prefix "Dropped INPUT packet: " --log-level 7 --log-uid
iptables -A INPUT -j DROP

### *filter FORWARD
iptables -A FORWARD -j DROP

### Fix for possible kernel packet-leak as discussed in,
### https://lists.torproject.org/pipermail/tor-talk/2014-March/032507.html
### uncomment below lines to log dropped packets

iptables -A OUTPUT -m conntrack --ctstate INVALID -j DROP
# iptables -A OUTPUT -m state --state INVALID -j LOG --log-prefix "Transproxy state leak blocked: " --log-uid
iptables -A OUTPUT -m state --state INVALID -j DROP

### *filter OUTPUT
iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT

# Allow Tor process output
iptables -A OUTPUT -m owner --uid-owner $_tor_uid -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -j ACCEPT

# Allow loopback output
iptables -A OUTPUT -d 127.0.0.1/32 -o lo -j ACCEPT

# Tor transproxy magic
iptables -A OUTPUT -d 127.0.0.1/32 -p tcp -m tcp --dport $_trans_port --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT

# Drop everything else.
iptables -A OUTPUT -j DROP

### Set default policies to DROP
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP
`
    fmt.Print(bcolors.BrightBlue + "(" + bcolors.BrightYellow + "Setting up firewall rules..\n" + bcolors.Endc)
    cmd := exec.Command("/bin/bash", "-c", innOutRules)
    cmd.Run()
    fmt.Print("                                                    " + bcolors.Green + "Done " + bcolors.BrightYellow + "✔" + bcolors.BrightBlue +")" + bcolors.Endc)
}

func resetToDefault(overidePass bool, resetAsChildFunc bool) {
    var resetTrigger int
    if !overidePass {
        if resetTrigger > 7 {
            fmt.Printf("%sexiting to prevent memory corruption.%s\n", bcolors.BrightRed, bcolors.Endc)
            //os.Exit(1)
        }
        var resetConsent string
        fmt.Printf("%s\nThis will overwrite all of your existing rules %sY(do it)%s/%sN(exit)%s: ", bcolors.Colors(), bcolors.Green, bcolors.Endc, bcolors.BrightRed, bcolors.Endc)
        fmt.Scanln(&resetConsent)
        if strings.ToLower(resetConsent) == "y" {
            //continue
        } else if strings.ToLower(resetConsent) == "n" {
            fmt.Printf("%sCopy that..\n%s", bcolors.BrightRed, bcolors.Endc)
            //os.Exit(1)
        } else {
            resetTrigger++
            resetToDefault(overidePass, resetAsChildFunc)
            return
        }

        time.Sleep(1 * time.Second)
        fmt.Printf("%sBacking up current rules, just in case..%s\n", bcolors.Magenta, bcolors.Endc)

        defaultCheckOne, defaultCheckNeo := checkDefaultRules()
        if defaultCheckNeo != "" {
            fmt.Printf("%sError while checking existing rules; %sexiting..\n%sError message: %s%s%s\n", bcolors.BrightRed, bcolors.BrightYellow, bcolors.Yellow, bcolors.Colors(), defaultCheckNeo, bcolors.Endc)
            //os.Exit(1)
        }
        if strings.TrimSpace(defaultCheckOne) != "0" {
            fileNameID := time.Now().Format("01_02_2006-15:04:05")
            cmd := exec.Command("sudo", "iptables-save", ">", "/tmp/iptables_"+fileNameID+".rules")
            cmd.Run()
            fmt.Printf("%sSaved in %s/tmp%s as %siptables_%s.rules%s\n", bcolors.BrightCyan, bcolors.BrightBlue, bcolors.Endc, bcolors.BrightRed, fileNameID, bcolors.Endc)
        } else {
            fmt.Printf("%s Default rules are set, backup not required :)%s\n", bcolors.BrightYellow, bcolors.Endc)
        }
        fmt.Printf("%s%sResetting Iptables%s\n", bcolors.BrightYellow, bcolors.Bold, bcolors.Endc)
    }
    iptablesRules := `
# Accepting all traffic first#
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT

# Flushing All Iptables Chains/Firewall rules #
iptables -F

# Deleting all Iptables Chains #
iptables -X

# Flushing all counters too #
iptables -Z
# Flush and delete all nat and  mangle #
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
`
    cmd := exec.Command("/bin/bash", "-c", iptablesRules)
    output, err := cmd.CombinedOutput()
    time.Sleep(500 * time.Millisecond)
    if err != nil {
        fmt.Printf("%sCan't reset Iptables%s\n", bcolors.Colors(), bcolors.Endc)
        fmt.Printf("%s%s%s\n", bcolors.Colors(), string(output), bcolors.Endc)
        //os.Exit(1)
    }
    if !resetAsChildFunc {
        fmt.Printf("%s Successfully reset Iptables to default :)%s\n", bcolors.BrightBlue, bcolors.Endc)
    }
}
